<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>实习</title>
      <link href="/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><h2 id="TCP-建立连接-TCP-数据传送-TCP-断开连接"><a href="#TCP-建立连接-TCP-数据传送-TCP-断开连接" class="headerlink" title="TCP 建立连接 TCP 数据传送 TCP 断开连接"></a>TCP 建立连接 TCP 数据传送 TCP 断开连接</h2><hr><h1 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h1><p>socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write/read –&gt; 关闭 close”模式来操作。Socket 就是该模式的一个实现， socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读/写 IO、打开、关闭）.说白了 Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。<br>注意：其实 socket 也没有层的概念，它只是一个 facade 设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过 socket 实现的。</p><hr><p><code>socket()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  socket(int protofamily, int type, int protocol);</span><br></pre></td></tr></table></figure><ul><li>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称 AF_UNIX，Unix 域 socket）、AF_ROUTE 等等。协议族决定了 socket 的地址类型，在通信中必须采用对应的地址，如 AF_INET 决定了要用 ipv4 地址（32 位的）与端口号（16 位的）的组合、AF_UNIX 决定了要用一个绝对路径名作为地址。</li><li>type：指定 socket 类型。常用的 socket 类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET 等等（socket 的类型有哪些？）。</li><li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC 等，它们分别对应 TCP 传输协议、UDP 传输协议、STCP 传输协议、TIPC 传输协议。<br><br>当`protocol`为`0`时，会自动选择`type`类型对应的默认协议</li></ul><hr><p><code>bind()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure><ul><li>sockfd：即 socket 描述字，它是通过 socket()函数创建了，唯一标识一个 socket。bind()函数就是将给这个描述字绑定一个名字。</li><li>addr：一个 const struct sockaddr *指针，指向要绑定给 sockfd 的协议地址。这个地址结构根据地址创建 socket 时的地址协议族的不同而不同。</li><li>addrlen：对应的是地址的长度。</li></ul><hr><p><code>close()</code>函数：关闭打开的文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure><hr><p><code>recvfrom()</code>/<code>sendto()</code>函数：网络 I/O 操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen);</span><br><span class="line">//从指定地址接收UDP数据报</span><br><span class="line"></span><br><span class="line">int sendto (int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen);</span><br><span class="line">//把UDP数据报发给指定地址</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center"></th><th align="left"></th></tr></thead><tbody><tr><td align="center"><div style="width: 50pt">\s</td><td align="left">socket 描述符。</td></tr><tr><td align="center">\buf</td><td align="left">UDP 数据报缓存地址。</td></tr><tr><td align="center">\len</td><td align="left">UDP 数据报长度。</td></tr><tr><td align="center">\flags</td><td align="left">该参数一般为 0。</td></tr><tr><td align="center">\to</td><td align="left">sendto()函数参数，struct sockaddr_in 类型，指明 UDP 数据发往哪里报。</td></tr><tr><td align="center">\tolen</td><td align="left">对方地址长度，一般为：sizeof(struct sockaddr_in)。</td></tr><tr><td align="center">\from</td><td align="left">recvfrom()函数参数，struct sockaddr 类型，指明 UDP 数据从哪里收。</td></tr><tr><td align="center">\fromlen</td><td align="left">recvfrom()函数参数，struct sockaddr_in 类型，指明从哪里接收 UDP 数据报。</td></tr></tbody></table><hr><p><code>inet_pton()</code>函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">//转换字符串到网络地址</span><br></pre></td></tr></table></figure><ul><li>第一个参数 af 是地址族，转换后存在 dst 中</li><li>af = AF_INET:src 为指向字符型的地址，即 ASCII 的地址的首地址（ddd.ddd.ddd.ddd 格式的），函数将该地址转换为 in_addr 的结构体，并复制在*dst 中.</li></ul><hr><p><code>htons()</code>函数：将端口号由主机字节序转换为网络字节序的整数值<br><code>inet_addr()</code>函数：将一个 IP 字符串转化为一个网络字节序的整数值</p><hr><hr><h1 id="libcurl库进行http通讯"><a href="#libcurl库进行http通讯" class="headerlink" title="libcurl库进行http通讯"></a><code>libcurl</code>库进行<code>http</code>通讯</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><pre><code>   libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。   在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。   libcurl主要提供了两种发送http请求的方式，分别是Easy interface方式和multi interface方式，前者是采用阻塞的方式发送单条数据，后者采用组合的方式可以一次性发送多条数据.</code></pre><h2 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h2><ol><li>在主线程中调用<code>curl_global_init(CURL_GLOBAL_ALL)</code>初始化</li><li>调用<code>curl_easy_init</code>获取一个句柄；</li><li>调用<code>curl_easy_setopt</code>函数设置此次传输的一些基本参数，如 url 地址、http 头、cookie 信息、发送超时时间等，其中，CURLOPT_URL 是必设的选项；</li><li>设置完成后，调用<code>curl_easy_perform</code>函数发送数据；</li><li>数据发送完毕后，调用<code>curl_easy_cleanup</code>清空句柄；</li><li>调用<code>curl_global_cleanup()</code>做清理工作。</li></ol><h2 id="3-基本函数"><a href="#3-基本函数" class="headerlink" title="3. 基本函数"></a>3. 基本函数</h2><ol><li><b>curl_global_init()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_global_init(long flags);//初始化libcurl</span><br><span class="line">函数只能调用一次，如果在curl_easy_init调用时还没调用，将有libcurl库自动调用</span><br><span class="line">虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init</span><br><span class="line">参数：flags</span><br><span class="line">CURL_GLOBAL_ALL              //初始化所有的可能的调用。</span><br><span class="line">CURL_GLOBAL_SSL              //初始化支持 安全套接字层。</span><br><span class="line">CURL_GLOBAL_WIN32            //初始化win32套接字库。</span><br><span class="line">CURL_GLOBAL_NOTHING          //没有额外的初始化</span><br><span class="line">CURL_GLOBAL_DEFAULT          //同时初始化SSL和Win32</span><br></pre></td></tr></table></figure><ol start="2"><li><b>void curl_global_cleanup()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void curl_global_cleanup(void)</span><br><span class="line">结束libcurl使用时，用来对curl_globl_init做的工作清理。</span><br><span class="line">虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init</span><br></pre></td></tr></table></figure><ol start="3"><li><b>char *curl_version()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印当前libcurl库的版本。</span><br></pre></td></tr></table></figure><ol start="4"><li><b>curl_easy_init()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数得到 easy interface型指针</span><br><span class="line">curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.</span><br><span class="line">一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</span><br></pre></td></tr></table></figure><ol start="5"><li><b>curl_easy_cleanup()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void curl_easy_cleanup(CURL *handle);</span><br><span class="line">//释放内存</span><br><span class="line">这个调用用来结束一个会话.与curl_easy_init配合着用.</span><br></pre></td></tr></table></figure><ol start="6"><li><b>curl_easy_setopt()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</span><br><span class="line">//设置传输选项</span><br><span class="line">几乎所有的curl 程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)</span><br><span class="line">参数:</span><br><span class="line">1. CURL类型的指针</span><br><span class="line">2. 各种CURLoption类型的选项.(都在curl.h库里有定义,man 也可以查看到)</span><br><span class="line">3. parameter 这个参数 既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数.</span><br><span class="line">CURLoption 这个参数的取值很多.具体的可以查看man手册.</span><br></pre></td></tr></table></figure><ol start="7"><li><b>curl_easy_perform()</b></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_easy_perform(CURL *handle);</span><br><span class="line">//函数完成传输任务</span><br><span class="line">这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用. 就像字面的意思所说perform就像是个舞台.让我们设置的option 运作起来.</span><br></pre></td></tr></table></figure><h2 id="4-curl-easy-perform-函数说明（error-状态码）"><a href="#4-curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="4. curl_easy_perform 函数说明（error 状态码）"></a>4. curl_easy_perform 函数说明（error 状态码）</h2><ol><li><code>CURLE_OK</code> //任务完成一切都好</li><li><code>CURLE_UNSUPPORTED_PROTOCOL</code> //不支持的协议，由 URL 的头部指定</li><li><code>CURLE_COULDNT_CONNECT</code> //不能连接到 remote 主机或者代理</li><li><code>CURLE_REMOTE_ACCESS_DENIED</code> //访问被拒绝</li><li><code>CURLE_HTTP_RETURNED_ERROR</code> //Http 返回错误</li><li><code>CURLE_READ_ERROR</code> //读本地文件错误<br><br>要获取详细的错误描述字符串，可以通过<code>const char *curl_easy_strerror(CURLcode errornum)</code>这个函数取得.</li></ol><h2 id="5-libcurl-使用的-HTTP-消息头"><a href="#5-libcurl-使用的-HTTP-消息头" class="headerlink" title="5. libcurl 使用的 HTTP 消息头"></a>5. libcurl 使用的 HTTP 消息头</h2><p>当使用<code>libcurl</code>发送<code>http</code>请求时，它会自动添加一些<code>http</code>头。我们可以通过<code>CURLOPT_HTTPHEADER</code>属性手动替换、添加或删除相应的<code>HTTP</code>消息头。<br>| | |<br>|:—|:—|<br>|Host|http1.1（大部分 http1.0)版本都要求客户端请求提供这个信息头。<br>|Pragma|”no-cache”。表示不要缓冲数据。<br>|Accept|”<em>/</em>“。表示允许接收任何类型的数据。<br>|Expect|以 POST 的方式向 HTTP 服务器提交请求时，libcurl 会设置该消息头为”100-continue”，它要求服务器</p><p>在正式处理该请求之前，返回一 个”OK”消息。如果 POST 的数据很小，libcurl 可能不会设置该消息头。<br><b>HTTP 协议提供了消息头，请求消息头用于告诉服务器如何处理请求;响应消息头则告诉浏览器如何处理接收到的数据。</b></p><h2 id="6-获取-http-应答头信息"><a href="#6-获取-http-应答头信息" class="headerlink" title="6. 获取 http 应答头信息"></a>6. 获取 http 应答头信息</h2><pre><code>   发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成。   需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：   CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );   info参数就是我们需要获取的内容，下面是一些参数值:   1.CURLINFO_RESPONSE_CODE   获取应答码   2.CURLINFO_HEADER_SIZE   头大小   3.CURLINFO_COOKIELIST   cookies列表   除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。</code></pre><h1 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h1><ul><li>南桥芯片接低速设备的 ISA 总线。</li><li>北桥芯片接高速设备的 PCI(E)总线+南桥芯片。</li></ul><p>CPU 频率很难提升，遂多 CPU 和多核出现。多核处理器是 SMP(symmetrical Multi-Processing)的简化版。</p><ol><li>预编译：gcc -E mian.c -o main.i</li><li>编译:gcc -S main.i -o main.s</li><li>汇编:gcc -c main.s -o main.o</li><li>链接:gcc -o main main.o</li></ol><p>生成共享文件 <code>gcc -fPIC -shared -o xx.so xx.c</code><br><br><code>shared</code> 产生共享对象<br><code>PIC</code> 地址无关代码</p><ul><li>预处理器：会扩展源代码,插入所有用#include 命令指定的文件,并扩展所有的宏。</li><li>編译器：产生源文件的汇编代码。</li><li>汇编器：会将汇编代码转化成二进制目标代码文件/或者说目标文件。</li><li>链接器：将<code>目标文件</code>与实现<code>标准库函数</code>(如 printf)的代码合并,并产生最终的可执行文件。</li></ul><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>链接就是将几个输入目标文件，加工并合并在一起组成一个输出文件的过程。<br><br>静态链接主要有两个步骤：空间及地址分配、符号解析与重定位</p><h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><ul><li>扫描所有输入目标文件，获得各段长度、属性和位置，并收集所有符号表中的符号定义和符号引用，放在一个统一的全局符号表内。</li><li>将输入文件中相同性质的段合并成输出文件的一个段，比如将输入文件所有的“.text”段合并成输出文件的“.text”。</li><li>为输出文件各段确定空间地址。空间地址有两种，一种是各段在可执行文件中的偏移地址，另一个是指进程的虚拟空间地址，链接过程主要关注虚拟空间地址。(这个过程实际上就是指定可执行文件与进程执行时的虚拟地址空间的映射关系)</li><li>由符号在段中的偏移值，确定各符号定义的虚拟地址。</li></ul><h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><ul><li>进行符号解析： 将各符号引用与输入文件某一个确定的符号定义联系在一起，如果找不到就报未定义错误。从普通程序员角度看，符号解析占链接的主要部分。</li><li>根据重定位表和符号定义的地址，确定每一个重定位入口的地址。<br>输入文件进行符号引用处，由于不知道相应符号的地址，所以需要将符号标记下来进行重定位，这个记录表就成为重定位表，或者重定位段。重定位表实质上是一个具有特定结构的数组，每一个数组元素都包含几点信息，重定位入口的偏移值、符号和重定位入口的类型。 -输入文件中每一个引用了外部符号的段都对应一个重定位段，如代码段“.text”对应的重定位段叫“.rel.text”.</li><li>指令地址修正。<br>由于不同 cpu 的寻址方式不同，所以每一个重定位入口处的实际地址都需要修正。指令修正由两个要素决定，该重定位入口的类型以及其虚拟地址。入口类型决定了指令修正方式，主要有绝对寻址修正和相对寻址修正两种。</li></ul><h2 id="COMMON-块"><a href="#COMMON-块" class="headerlink" title="COMMON 块"></a>COMMON 块</h2><p>当不同的文件目标需要的 COMMON 块空间大小不一致时，以最大的为准<br><br>一个弱符号定义在多个目标文件中，而类型不同<br></p><ul><li>1.两个或两个以上强符号类型不一致（多个强符号定义非法）</li><li>2.有一个强符号，其他都是弱符号（输出结果和强符号相同）</li><li>3.两个或两个以上的弱符号类型不一致（以输入文件最大的为准）</li></ul><p>连接器不支持符号类型，无法判断各个符号类型是否一致</p><p>ccglDd89.o: In function ‘PanaSearchCameras’<br><br>error: ld returned 1 exit status<br><br>链接时失败， pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a<br>在编译中要加 -lpthread 参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc thread.c -o thread -lpthread</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, argc);</span><br><span class="line">    for(int i = 0; i &lt; argc; i ++)</span><br><span class="line">        printf(&quot;%s\n&quot;, argv[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>gcc main.c -o main</li><li>./main 11 22 33</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">./main</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br></pre></td></tr></table></figure><p>所有分配出来的栈空间的每一个字节被初始化为<code>0xCC</code>,<code>0xCCCC</code>汉字编码为“<code>烫</code>”</p><h1 id="c-primer-2022-12-5"><a href="#c-primer-2022-12-5" class="headerlink" title="c++primer 2022/12/5"></a>c++primer 2022/12/5</h1><h2 id="负数取余问题"><a href="#负数取余问题" class="headerlink" title="负数取余问题"></a>负数取余问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char b = -1;</span><br><span class="line">b = 255;</span><br></pre></td></tr></table></figure><h3 id="如果-a-和-d-是两个自然数，d-非零，可以证明存在两个唯一的整数-q-和-r，满足-a-qd-r-且-0-≤-r-lt-d；两个数取余，余数总是为正数。"><a href="#如果-a-和-d-是两个自然数，d-非零，可以证明存在两个唯一的整数-q-和-r，满足-a-qd-r-且-0-≤-r-lt-d；两个数取余，余数总是为正数。" class="headerlink" title="如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a=qd+r 且 0 ≤ r &lt; d；两个数取余，余数总是为正数。"></a>如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a=qd+r 且 0 ≤ r &lt; d；两个数取余，余数总是为正数。</h3><blockquote><p>5%3=3x1+2，商为 1，余数为 2；<br>(-5)%(-3)=(-3)x2+1，商为 2，余数为 1；<br>5%(-3)=(-3)x(-1)+2，商为-1，余数为 2；<br>(-5)%3=3x(-2)+1，商为-2，余数为 1；</p></blockquote><h3 id="如果-a-与-d-是整数，d-非零，那么余数-r-满足这样的关系：a-qd-r-q-为整数，且-0-≤-r-lt-d-；"><a href="#如果-a-与-d-是整数，d-非零，那么余数-r-满足这样的关系：a-qd-r-q-为整数，且-0-≤-r-lt-d-；" class="headerlink" title="如果 a 与 d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且 0 ≤ |r| &lt; |d|；"></a>如果 a 与 d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且 0 ≤ |r| &lt; |d|；</h3><blockquote><p>5%(-3) = (-3)x(-1)+2 = (-3)x(-2)-1；<br>如果正余数为 r1，负余数为 r2，那么有 r1 = r2 + d；<br>所有语言和计算器都遵循了尽量让商尽量靠近 0 的原则，即 5%(-3) 的结果为 2 而不是-1，(-5)%3 的结果是-2 而不是 1。</p></blockquote><h2 id="转义字符-输出“1”"><a href="#转义字符-输出“1”" class="headerlink" title="转义字符 输出“1”"></a>转义字符 输出“1”</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;\&quot;1\&quot;&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>(1)‘a ‘, L’a’, “a”, L”a” //字符字面值，宽字符字面值，字符串字面值，宽字符串字面值；<br><br>(2) 10, 10u, 10L, 10uL, 012, 0xC //整形字面值，无符号整形字面值，长整形字面值，无符号长整形字面值，八进制整形字面值，十六进制整形字面值；<br><br>(3) 3.14, 3.14f, 3.14L //浮点型字面值，单精度浮点型字面值，扩展精度浮点型字面值；<br><br>(4) 10, 10u, 10., 10e-2 //整形字面值，无符号整形字面值，浮点型字面值，浮点型字面值。<br></p><h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>一个特性，它的第 n+1 行第 m+1 列的元素值为 C(n,m);<br>n!/(n - m)!m!</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">       int i = 100;</span><br><span class="line">       for (int i = 0; i &lt; 1; i++)</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; endl;//0</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; endl;//100</span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三章-字符串、向量、数组"><a href="#第三章-字符串、向量、数组" class="headerlink" title="第三章 字符串、向量、数组"></a>第三章 字符串、向量、数组</h2><h3 id="命名空间-using-声明"><a href="#命名空间-using-声明" class="headerlink" title="命名空间 using 声明"></a>命名空间 <code>using</code> 声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure><h3 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型<code>string</code></h3><blockquote><p>可变长的字符序列<br>string 对象的下标运算符可用于访问已存在的元素，不可以用于添加元素</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">string s1;</span><br><span class="line">string s2(s1);</span><br><span class="line">string s2 = s1;            等同于s2(s1)</span><br><span class="line">string s3(&quot;value&quot;);</span><br><span class="line">string s3 = &quot;value&quot;;       等同于s3(&quot;value&quot;)</span><br><span class="line">string s4(n, &#x27;c&#x27;);         把s4初始为连续n个c组成的串</span><br></pre></td></tr></table></figure><blockquote><p>string 操作</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s           //将s写到输出流os中，返回os</span><br><span class="line">is &gt;&gt; s           //从is中读取字符串赋给s，字符串以空白分隔，返回is</span><br><span class="line">getline(is, s)    //从is中读取一行赋给s，返回is</span><br><span class="line">s.empty()         //s为空返回true，否则返回false ，返回bool类型</span><br><span class="line">s.size()          //返回s中字符的个数</span><br><span class="line">s[n]              //返回s中第n个字符的引用，位置n从0计起</span><br><span class="line">s1 + s2           //返回s1和s2连接后的结果</span><br><span class="line">s1 = s2           //用s2中的副本替代s1中原来的字符</span><br><span class="line">s1 == s2          //判s1和s2等不等</span><br><span class="line">s1 = s2           //对大小写敏感</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=      //利用字符在字典中的顺序进行比较</span><br></pre></td></tr></table></figure><blockquote><p>cctype 头文件中的函数</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)    //c全为数字或数字式时为真</span><br><span class="line">isalpha(c)    //c全为字母时为真</span><br><span class="line">iscntrl(c)    //c是控制字符时为真</span><br><span class="line">isdigit(c)    //当c是数字时为真</span><br><span class="line">isgragh(c)    //当c不是空格但可打印时为真</span><br><span class="line">islower(c)    //当c不是小写字母时为真</span><br><span class="line">isprint(c)    //当c是可打印字符时为真</span><br><span class="line">ispunct(c)    //当c是标点符号时为真</span><br><span class="line">isspace(c)    //当c是空白时为真</span><br><span class="line">isupper(c)    //当c为大写字母时为真</span><br><span class="line">isxdigit(c)   //当c是十六进制数字时为真</span><br><span class="line">tolower(c)    //c输出对应的小写字母</span><br><span class="line">toupper(c)    //输出对应的大写字母</span><br></pre></td></tr></table></figure><blockquote><p>读取未知量的<code>string</code>对象</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string word;</span><br><span class="line">      while(cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>getline</code> 读取一整行</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line)) cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>empty</code> 函数 返回一个布尔值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line))</span><br><span class="line">           if(！line.empty())  //判断是否为空行</span><br><span class="line">                 cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>size</code> 函数 返回<code>string</code>长度</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line))</span><br><span class="line">           if(line.size() &gt; 10)  //判断长度是否大于10</span><br><span class="line">                 cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>string</code>类<code>size</code>函数返回值为<code>size_type</code>类型<br><code>string</code>比较时采用字典序<br><code>string</code>相加时不能字面值直接相加</p></blockquote><h1 id="c-primer-2022-12-6"><a href="#c-primer-2022-12-6" class="headerlink" title="c++primer 2022/12/6"></a>c++primer 2022/12/6</h1><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型<code>vector</code></h3><blockquote><p>标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 vector。（如果不确定元素的确切个数，使用 vector 而不使用数组）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//头文件</span><br><span class="line">#include &lt;vector&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">vector&lt;int&gt; v1(10, 1)      //10个元素,初值为1;</span><br><span class="line">vector&lt;int&gt; v2&#123;10, 1&#125;      //2个元素,分别为10, 1;</span><br><span class="line">vector&lt;string&gt; v3&#123;10&#125;      //10个元素,花括号内的值类型和元素类型相同为列表初始化;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//vector操作</span><br><span class="line">v.empty()           判空</span><br><span class="line">v.size()            返回v的个数</span><br><span class="line">v.push_back(t)      向v末尾添加t</span><br><span class="line">v[n]                返回v的第n个引用</span><br><span class="line">v1 = v2             用v2的元素拷贝替换v1</span><br><span class="line">v1 = &#123;a, b, c&#125;      用列表元素拷贝替换v1</span><br><span class="line">v1 == v2            当且仅当元素个数及相应元素值相同时相等</span><br><span class="line">v1 != v2</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=       以字典序比较</span><br></pre></td></tr></table></figure><blockquote><p><code>vector</code>对象的下标运算符可用于访问已存在的元素，不可以用于添加元素</p></blockquote><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote><p>所有标准库容器都可以使用迭代器</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//运算符</span><br><span class="line">*iter               //返回迭代器所指元素的引用</span><br><span class="line">iter-&gt;mem           //解引用iter并获取该元素的名为mem的成员，等价于*iter.mem</span><br><span class="line">++iter              //令iter指示容器中的下一个元素</span><br><span class="line">--iter              //令iter指示容器中的上一个元素</span><br><span class="line">iter1 == iter2      //判等</span><br><span class="line">iter1 != iter2      //判不等</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//运算</span><br><span class="line">iter + n</span><br><span class="line">iter - n</span><br><span class="line">iter += n</span><br><span class="line">iter -= n</span><br><span class="line">iter1 - iter2    //两迭代器之间的距离，注意是没有加法运算的迭代器之间。</span><br><span class="line">&gt;, &gt;=, &lt;, &lt;=     //实质是比较两迭代器间的位置</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型</span><br><span class="line">vector&lt;int&gt;::iterator it1;    //知道类型的定义方式、可读写</span><br><span class="line">string::iterator it2;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::const_iterator it3;</span><br><span class="line">string::const_iterator it4;    //只读</span><br></pre></td></tr></table></figure><blockquote><p><code>begin</code>和<code>end</code></p></blockquote><p><code>begin</code>：返回指向的第一个元素的迭代器。<br><code>end</code>：返回容器“尾元素的下一个元素”的迭代器。<br>如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是尾后迭代器。</p><p><code>begin</code>的具体返回类型由对象是否是常量决定，如果对象是常量，<code>begin</code>和<code>end</code>返回<code>const_iterator</code>；如果不是常量，返回<code>iterator</code>。（选用<code>auto</code>自行决定返回类型比较保险）</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote><p>数组的大小固定（使用下标访问时必须严格检查是否在合理范围内）</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//字符数组的特殊性：可以使用字符串字面值进行初始化，但是结尾处有一处空字符。</span><br><span class="line">char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;;    //无空字符</span><br><span class="line">char a2[] = &quot;C++&quot;               //结尾默认生成空字符&#x27;\0&#x27;,(为了容纳空字符，故如果规定大小的话，大小必须为4以上)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不允许拷贝和赋值</span><br><span class="line">int a[] = &#123;o,1,2&#125;;      //正确</span><br><span class="line">int b[] = a;            //错误</span><br><span class="line">a2 = a;                 //错误</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//数组的指针与引用</span><br><span class="line">int *ptrs[10];                  //ptrs是含有10个整型指针的数组</span><br><span class="line">int &amp;refs[10] = ...;            //错误：不存在引用的数组</span><br><span class="line">int (*Parray)[10] = &amp;arr;       //Parray指向一个含有十个整数的数组</span><br><span class="line">int (&amp;arrRef)[10] = arr;        //arrRef引用一个含有10个整数的数组</span><br></pre></td></tr></table></figure><blockquote><p>相比于<code>vector</code>来说，数组的缺点</p></blockquote><ul><li>不能向数组增加元素，数组大小固定，不灵活。</li><li>vector 可以更好地支持标准库 std。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//指针+数组</span><br><span class="line">string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;</span><br><span class="line">string *p = &amp;nums[0];                   //p指向nums的第一个元素</span><br><span class="line">string *p2 = nums;                      //等价如上</span><br><span class="line"></span><br><span class="line">int ia = &#123;0,1,2,3,4&#125;;</span><br><span class="line">auto ia2(ia);                           //ia2是一个整型指针，指向ia的第一个元素</span><br><span class="line">auto ia2(&amp;ia[0])                        //等价如上</span><br></pre></td></tr></table></figure><h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><blockquote><p>位运算符作用于整型的运算对象，并把运算对象通过 二进制 的方式理解，并提供检查和设置二进制的功能。</p></blockquote><table><thead><tr><th align="center">运算符</th><th align="center">功能</th><th align="center">用法</th><th align="center">运算规则</th></tr></thead><tbody><tr><td align="center"><code>~</code></td><td align="center">位求反</td><td align="center"><code>~</code> expr</td><td align="center">~1 = 0; ~0 = 1<br> ~1 = -2; ~-1 = 0; ~0 = -1</td></tr><tr><td align="center"><code>&lt;&lt;</code></td><td align="center">左移</td><td align="center">expr1 <code>&lt;&lt;</code> expr2</td><td align="center"></td></tr><tr><td align="center"><code>&gt;&gt;</code></td><td align="center">右移</td><td align="center">expr1 <code>&gt;&gt;</code> expr2</td><td align="center"></td></tr><tr><td align="center"><code>&amp;</code></td><td align="center">位与</td><td align="center">expr <code>&amp;</code> expr</td><td align="center">0 &amp; 0 = 0<br>0 &amp; 1 = 0<br>1 &amp; 0 = 0<br>1 &amp; 1 = 1</td></tr><tr><td align="center"><code>^</code></td><td align="center">位异或</td><td align="center">expr <code>^</code> expr</td><td align="center">0 ^ 0 = 0<br>0 ^ 1 = 1<br>1 ^ 0 = 1<br>1 ^ 1 = 0</td></tr><tr><td align="center"><code>|</code></td><td align="center">位或</td><td align="center">expr <code>|</code> expr</td><td align="center">0 | 0 = 0<br>0 | 1 = 1<br>1 | 0 = 1<br>1 | 1 = 1</td></tr></tbody></table><h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h3><blockquote><p>返回一条表达式或一个类型名字所占的字节数。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line">sizeof(Sales_data);            //Sales_data类型的对象所占的空间大小</span><br><span class="line">sizeof data;                   //data类型的大小，结果如上</span><br><span class="line">sizeof p;                      //指针所占的空间大小</span><br><span class="line">sizeof *p;                     //指针所指的类型所占的空间大小，即sizeof(Sales_data)</span><br><span class="line">sizeof data.revenue;           //Sales_data的成员reveune对应类型的大小</span><br><span class="line">sizeof Sales_data::revenue;    //Sales_data的成员reveune对应类型的大小</span><br></pre></td></tr></table></figure><blockquote><p>sizeof 运算符的结果部分地依赖于其作用的类型：</p><ul><li>对 char 或者类型为 char 的表达式执行 sizeof 运算符，结果得 1。</li><li>对引用类型执行 sizeof 运算得到被引用对象所占空间的大小。</li><li>对指针执行 sizeof 运算得到指针本身所占空间的大小。</li><li>对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需要有效。</li><li>对数组执行 sizeof 运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次 sizeof 运算并将所得结果求和。注意，sizeof 运算不会把数组转换成指针来处理。</li><li>对 string 对象或 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li></ul></blockquote><h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote><p>优先级最低,先对左值进行计算，然后丢弃，真正的结果是右侧表达式的值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (0, 1);         //输出1</span><br></pre></td></tr></table></figure><h3 id="try-语句块和异常处理"><a href="#try-语句块和异常处理" class="headerlink" title="try 语句块和异常处理"></a>try 语句块和异常处理</h3><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote><p><strong>重载函数（overloaded function）</strong>：同一作用域内的几个函数的函数名相同，但参数列表不同。参数列表不同指的是参数类型和数量不全相同。如果只是返回类型不同，这么定义重载函数是错误的，因为大多数重载函数是根据形参来匹配相应重载函数。</p></blockquote><blockquote><p><strong>main 函数不能重载</strong></p></blockquote><blockquote><p>对于形参是某种类型的引用或者指针时，则通过区分其指向的是常量对象还是非常量对象以实现函数重载。这里的<code>const</code>是底层<code>const</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以下4个函数的形参类型不同</span><br><span class="line">void look(const int *a);</span><br><span class="line">void look (int* a);</span><br><span class="line"></span><br><span class="line">void look(const int &amp;a);</span><br><span class="line">void look(int &amp; a);</span><br></pre></td></tr></table></figure><blockquote><p><strong>函数匹配（function matching）</strong>：是指一个把函数调用与一组重载函数中的某一个关联起来的过程，也叫<strong>重载确定（overload resolution）</strong>，编译器首先将调用的实参与一组重载函数中每一个函数的参数列表进行比较，再根据比较的结果选择并调用最佳函数。</p></blockquote><blockquote><p>调用重载函数会有三种可能的结果：</p><ul><li>编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</li><li>找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。</li><li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生名为二义性调用的错误。</li></ul></blockquote><blockquote><p>重载与作用域</p><ul><li>在不同作用域无法重载函数名，内层作用域声明的标识符会覆盖掉外层作用域的标识符</li><li>C++的名字查找发生在类型检查之前</li></ul></blockquote><blockquote><p>内联函数和<code>constexpr</code>函数</p><ul><li>调用函数会导致一些时间和空间上的开销：保存调用者保存寄存器和被调用者保存寄存器，并在函数返回时恢复；将参数拷贝进栈中；栈顶指针寄存器和基址指针寄存器的存取等操作会消耗时间和空间。</li><li>内联函数（inline function）：在每个调用点上“内联地”展开的函数，不会产生常规函数时间和空间上的开销，与宏类似。</li><li>内联函数的声明：在函数声明前面加上关键字<code>inline</code>。</li><li>内联函数适用于优化规模较小、流程直接、频繁调用的函数。</li></ul></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline const string &amp; shorterString(const string &amp;s1, const string &amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">  return s1.size() &lt;= size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>constexpr</code>函数(constexpr function)</strong>: 是指能用于常量表达式的函数。</p></blockquote><blockquote><p>定义 constexpr 函数的要求</p><ul><li>函数的返回类型和所有形参的类型都必须是字面值类型，并且返回类型前还要加上关键字 constexpr</li><li>函数体中有且只有一条 return 语句；</li><li>函数体中的语句除了 return 语句外，其它语句必须是在运行时不执行任何操作的，例如空语句、声明类型别名、 using 声明等语句；</li></ul></blockquote><blockquote><p><code>constexpr</code>函数被隐式地指定为内联函数 ，以方便在编译过程中展开</p></blockquote><blockquote><p>与其他函数不同，内联函数和<code>constexpr</code>函数可以定义多次，但是它的多个定义必须完全一致。 所以内联函数和<code>constexpr</code>函数一般都定义在头文件中。</p></blockquote><h1 id="c-primer-2022-12-7"><a href="#c-primer-2022-12-7" class="headerlink" title="c++primer 2022/12/7"></a>c++primer 2022/12/7</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul><li><strong>类的基本思想</strong>：**数据抽象(data abstraction)<strong>和</strong>封装(encapsulation)**。</li><li><strong>数据抽象</strong>：是一种依赖于**接口(interface)<strong>和实现</strong>(implementation)**分离的编程(以及设计)技术。</li><li><strong>类的接口</strong>：包含了用户所能执行的操作。</li><li><strong>类的实现</strong>：包含了类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。</li><li><strong>封装</strong>：实现了类的<strong>接口</strong>和<strong>实现</strong>的分离，隐藏了类的实现细节，使得用户只能使用类的接口而无法查看其实现细节。</li></ul><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="函数的声明、调用、定义"><a href="#函数的声明、调用、定义" class="headerlink" title="函数的声明、调用、定义"></a>函数的声明、调用、定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void simple();      //函数的声明</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;main() will call the simple() function:&quot; &lt;&lt; endl;</span><br><span class="line">simple();       //函数调用</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void simple(void)   //函数定义</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; &quot;I&#x27;m but a simple function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int, int); //函数的声明</span><br><span class="line">void swap(int*, int*);</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">swap(a, b); //函数调用</span><br><span class="line">swap(&amp;a, &amp;b);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int a1, int b1) //函数定义</span><br><span class="line">&#123;</span><br><span class="line">a1 ^= b1 ^= a1 ^= b1;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//10  20</span><br><span class="line">&#125;</span><br><span class="line">void swap(int* a1, int* b1) //函数定义</span><br><span class="line">&#123;</span><br><span class="line">*a1 ^= *b1 ^= *a1 ^= *b1;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//20 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int ArSize = 8;</span><br><span class="line">int sum_arr(int arr[], int);</span><br><span class="line">int cookies[ArSize] = &#123; 1, 2, 4, 8, 16, 32, 64, 128 &#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int sum = sum_arr(cookies, ArSize);</span><br><span class="line">cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; cookies[7] &lt;&lt; endl;     //129</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">int sum_arr(int arr[], int n)</span><br><span class="line">&#123;</span><br><span class="line">int total = 0;</span><br><span class="line">for (int i = 0; i &lt; n; i++)</span><br><span class="line">total += arr[i];</span><br><span class="line">cout &lt;&lt; arr &lt;&lt; endl &lt;&lt; cookies &lt;&lt; endl;</span><br><span class="line">arr[7] = 129;</span><br><span class="line">return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>const</code>常量保证值不能被改变，其实保证的是常量指向的内存地址所保存的数据不能被修改<br>‘基本数据类型‘的 值就保存在内存地址中，所以 const 定义的 ‘基础数据类型’ 不可被改变。</p><p>而引用数据类型指向的内存地址只是一个指针，通过指针来指向实际数据，也就是说，不可被改变的是指针，而不是数据，所以 const 定义的 ”引用数据类型的常量可以通过属性来修改值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">int n = 10, m = 100;</span><br><span class="line">const int* p = &amp;m;</span><br><span class="line">int* const q = &amp;m;</span><br><span class="line">const int* const t = &amp;m;</span><br><span class="line">p = &amp;n;</span><br><span class="line">cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; endl;//00000063EA4FFAE4 10</span><br><span class="line">*q = n;</span><br><span class="line">cout &lt;&lt; &quot;*q = &quot; &lt;&lt; *q &lt;&lt; endl;//10</span><br><span class="line">cout &lt;&lt; &quot;q = &quot; &lt;&lt; q &lt;&lt; endl;//m的地址</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="用到的一些函数"><a href="#用到的一些函数" class="headerlink" title="用到的一些函数"></a>用到的一些函数</h1><h2 id="1-fopen"><a href="#1-fopen" class="headerlink" title="1.fopen()"></a>1.fopen()</h2><p><code>FILE *fopen(const char *filename, const char *mode)</code><br><br><code>filename</code> – 字符串，表示要打开的文件名称。<br><br><code>mode</code> – 字符串，表示文件的访问模式，可以是以下表格中的值</p><table><thead><tr><th align="left">模式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">“Y”</td><td align="left">打开一个用于读取的文件。该文件必须存在。</td></tr><tr><td align="left">“w”</td><td align="left">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td></tr><tr><td align="left">“a”</td><td align="left">追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</td></tr><tr><td align="left">“r+”</td><td align="left">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td></tr><tr><td align="left">“w+”</td><td align="left">创建一个用于读写的空文件。</td></tr><tr><td align="left">“a+”</td><td align="left">打开一个用于读取和追加的文件。</td></tr></tbody></table><h2 id="2-sscanf-从字符串读取格式化输入"><a href="#2-sscanf-从字符串读取格式化输入" class="headerlink" title="2.sscanf() //从字符串读取格式化输入"></a>2.sscanf() //从字符串读取格式化输入</h2><p><code>int sscanf(const char *str, const char *format, ...)</code><br><br><code>str</code> – 这是 C 字符串，是函数检索数据的源。<br><br><code>format</code> – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 <code>format</code> 说明符。<br><code>format</code> 说明符形式为 <code>[=%[*][width][modifiers]type=]</code><br>|参数|描述|<br>|:—|:—|<br>|*| 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。|<br>|width|这指定了在当前读取操作中读取的最大字符数。|<br>|modifiers|为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）|<br>|type|一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。|</p><table><thead><tr><th align="left">类型</th><th align="left">合格的输入</th><th align="left">参数类型</th></tr></thead><tbody><tr><td align="left">c</td><td align="left">单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td><td align="left">char *</td></tr><tr><td align="left">d</td><td align="left">十进制整数：数字前面的 + 或 - 号是可选的。</td><td align="left">int *</td></tr><tr><td align="left">e,E,f,g,G</td><td align="left">浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td><td align="left">float *</td></tr><tr><td align="left">o</td><td align="left">八进制整数。</td><td align="left">int *</td></tr><tr><td align="left">s</td><td align="left">字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td><td align="left">char *</td></tr><tr><td align="left">u</td><td align="left">无符号的十进制整数。</td><td align="left">unsigned int *</td></tr><tr><td align="left">x,X</td><td align="left">十六进制整数。</td><td align="left">int *</td></tr></tbody></table><p><strong>附加参数</strong> – 这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。<br><br>成功返回的是成功转换的值的个数</p><h2 id="3-fprintf-发送格式化输出到流-stream-中。"><a href="#3-fprintf-发送格式化输出到流-stream-中。" class="headerlink" title="3.fprintf() //发送格式化输出到流 stream 中。"></a>3.fprintf() //发送格式化输出到流 stream 中。</h2><p><code>int fprintf(FILE *stream, const char *format, ...)</code><br><br><code>stream</code> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。<br><br><code>format</code> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</p><h2 id="4-curl-easy-perform-curl-easy-perform-执行阻止文件传输"><a href="#4-curl-easy-perform-curl-easy-perform-执行阻止文件传输" class="headerlink" title="4.curl_easy_perform() //curl_easy_perform - 执行阻止文件传输"></a>4.curl_easy_perform() //curl_easy_perform - 执行阻止文件传输</h2><p><code>CURLcode curl_easy_perform(CURL *easy_handle)</code><br><br>在<code>curl_easy_init</code>和所有<code>curl_easy_setopt</code>调用后调用此函数，并按照选项中所述执行传输。必须使用与返回的<code>curl_easy_init</code>调用相同的输入<code>easy_handle</code>调用它。<code>libcurl</code>将尝试在后续传输中重复使用相同的连接</p><h2 id="5-curl-easy-strerror-返回描述错误代码的字符串"><a href="#5-curl-easy-strerror-返回描述错误代码的字符串" class="headerlink" title="5.curl_easy_strerror() //返回描述错误代码的字符串"></a>5.curl_easy_strerror() //返回描述错误代码的字符串</h2><p><code>const char *curl_easy_strerror(CURLcode errornum);</code><br><br>返回一个字符串，描述在参数 errornum 中传递的 CURLcode 错误代码。</p><h2 id="6-fclose-关闭流-stream。刷新所有的缓冲区。"><a href="#6-fclose-关闭流-stream。刷新所有的缓冲区。" class="headerlink" title="6.fclose() //关闭流 stream。刷新所有的缓冲区。"></a>6.fclose() //关闭流 stream。刷新所有的缓冲区。</h2><p><code>int fclose(FILE *stream)</code><br><br><code>stream</code> – 这是指向 <code>FILE</code> 对象的指针，该 <code>FILE</code> 对象指定了要被关闭的流。<br><br>如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。</p><h2 id="7：pthread-mutex-init-初始化锁变量-mutex。"><a href="#7：pthread-mutex-init-初始化锁变量-mutex。" class="headerlink" title="7：pthread_mutex_init() //初始化锁变量 mutex。"></a>7：pthread_mutex_init() //初始化锁变量 mutex。</h2><p>pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t *attr)<br>attr 为锁属性，NULL 值为默认属性。</p><h2 id="8：pthread-mutex-lock-加锁"><a href="#8：pthread-mutex-lock-加锁" class="headerlink" title="8：pthread_mutex_lock() //加锁"></a>8：pthread_mutex_lock() //加锁</h2><p>pthread_mutex_lock(pthread_mutex_t *mutex)</p><h2 id="9：pthread-mutex-tylock-加锁，但是与-8-不一样的是当锁已经在使用的时候，返回为-EBUSY，而不是挂起等待。"><a href="#9：pthread-mutex-tylock-加锁，但是与-8-不一样的是当锁已经在使用的时候，返回为-EBUSY，而不是挂起等待。" class="headerlink" title="9：pthread_mutex_tylock() //加锁，但是与 8 不一样的是当锁已经在使用的时候，返回为 EBUSY，而不是挂起等待。"></a>9：pthread_mutex_tylock() //加锁，但是与 8 不一样的是当锁已经在使用的时候，返回为 EBUSY，而不是挂起等待。</h2><p>pthread_mutex_tylock(pthread_mutex_t *mutex)</p><h2 id="10：pthread-mutex-unlock-释放锁"><a href="#10：pthread-mutex-unlock-释放锁" class="headerlink" title="10：pthread_mutex_unlock() //释放锁"></a>10：pthread_mutex_unlock() //释放锁</h2><p>pthread_mutex_unlock(pthread_mutex_t *mutex)</p><h2 id="11：pthread-mutex-destroy-使用完后释放"><a href="#11：pthread-mutex-destroy-使用完后释放" class="headerlink" title="11：pthread_mutex_destroy() //使用完后释放"></a>11：pthread_mutex_destroy() //使用完后释放</h2><p>pthread_mutex_destroy(pthread_mutex_t *mutex)</p>]]></content>
      
      
      <categories>
          
          <category> 实习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/2022/11/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="22-11-23-天气阴"><a href="#22-11-23-天气阴" class="headerlink" title="22-11-23 天气阴"></a>22-11-23 天气阴</h2><h2 id="嘎嘎感谢我尧姐请我吃饭，感动啊"><a href="#嘎嘎感谢我尧姐请我吃饭，感动啊" class="headerlink" title="嘎嘎感谢我尧姐请我吃饭，感动啊"></a>嘎嘎感谢我尧姐请我吃饭，感动啊</h2><h2 id="感谢我左老板送我到车站，太感动了"><a href="#感谢我左老板送我到车站，太感动了" class="headerlink" title="感谢我左老板送我到车站，太感动了"></a>感谢我左老板送我到车站，太感动了</h2><h2 id="感谢大家对我的关心"><a href="#感谢大家对我的关心" class="headerlink" title="感谢大家对我的关心"></a>感谢大家对我的关心</h2><h1 id="去实习"><a href="#去实习" class="headerlink" title="去实习"></a>去实习</h1><p>火车真的累啊，二十三个小时，下车也真的麻烦，这个疫情真的麻烦<br>住宿的环境确实很一般，免费的就这样吧。宿舍离公司还远，还需要公交车，离谱。<br>还没上班就花出去一天工资买生活用品，离谱。<br>明天去公司报道，希望一切顺利</p>]]></content>
      
      
      <categories>
          
          <category> 杂物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/2022/11/11/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/11/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="22-11-11-天气多云"><a href="#22-11-11-天气多云" class="headerlink" title="22-11-11 天气多云"></a>22-11-11 天气多云</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><p>本来想将博客搭建到服务器上，但是出现了很多问题没有解决</p><h4 id="错误-1"><a href="#错误-1" class="headerlink" title="错误 1"></a>错误 1</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Permission denied, please try again</span><br></pre></td></tr></table></figure><p>在服务器创建用户后，用这个用户连接，没有权限，不知道怎么解决，后面用 root 直接连接，把博客文件传到服务器，但是不能用公网 ip 访问。</p><h4 id="错误-2"><a href="#错误-2" class="headerlink" title="错误 2"></a>错误 2</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Please make sure you have the correct access rights and the repository exists.</span><br></pre></td></tr></table></figure><h4 id="错误-3"><a href="#错误-3" class="headerlink" title="错误 3"></a>错误 3</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FATAL &#123;</span><br><span class="line">  err: Error: Spawn failed</span><br><span class="line">      at ChildProcess.&lt;anonymous&gt; (E:\BKXM\bk\blog-demo\node_modules\hexo-util\lib\spawn.js:51:21)</span><br><span class="line">      at ChildProcess.emit (node:events:527:28)</span><br><span class="line">      at ChildProcess.cp.emit (E:\BKXM\bk\blog-demo\node_modules\cross-spawn\lib\enoent.js:34:29)</span><br><span class="line">      at Process.ChildProcess._handle.onexit (node:internal/child_process:291:12) &#123;</span><br><span class="line">    code: 128</span><br><span class="line">  &#125;</span><br><span class="line">&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html</span><br></pre></td></tr></table></figure><h4 id="错误-3-解决方法"><a href="#错误-3-解决方法" class="headerlink" title="错误 3 解决方法"></a>错误 3 解决方法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">删除名为.deploy_git的文件夹，rm -rf .deploy_git</span><br><span class="line">git config --global core.autocrlf false</span><br><span class="line">hexo c;hexo g;hexo d</span><br></pre></td></tr></table></figure><p>最后直接在 GitHub 拉取文件，可以用公网 ip 访问，但是不能实时更新，需要手动拉去 GitHub 文件</p><blockquote><p><a href="http://43.139.12.60/">http://43.139.12.60/</a><br>hehao.love<br>heha001.github.io</p></blockquote><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>论文进度++<br>@Controller<br>@RequestMapping(“/blog/bContent”)<br>public class ContentController extends BaseController {<br>@Autowired<br>ContentService bContentService;<br>@Autowired<br>private CategoryInfoService categoryInfoService;<br>@GetMapping()<br>String bContent() {<br>return “blog/bContent/bContent”;<br>}</p><p>@ResponseBody<br>@GetMapping(“/list”)<br>public PageUtils list(@RequestParam Map&lt;String, Object&gt; params) {<br>params.put(“created”,getUserId());<br>Query query = new Query(params);<br>List<ContentDO> bContentList = bContentService.list(query);<br>int total = bContentService.count(query);<br>PageUtils pageUtils = new PageUtils(bContentList, total);<br>return pageUtils;<br>}<br>@GetMapping(“/add”)<br>String add(Model model) {<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/add”;<br>}<br>@GetMapping(“/edit/{cid}”)<br>String edit(@PathVariable(“cid”) Long cid, Model model) {<br>ContentDO bContentDO = bContentService.get(cid);<br>model.addAttribute(“bContent”, bContentDO);<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/edit”;<br>}<br>@GetMapping(“/add0”)<br>String add0(Model model) {<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/add0”;<br>}<br>@GetMapping(“/edit0/{cid}”)<br>String edit0(@PathVariable(“cid”) Long cid, Model model) {<br>ContentDO bContentDO = bContentService.get(cid);<br>model.addAttribute(“bContent”, bContentDO);<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/edit0”;<br>}<br>@GetMapping(“/add1”)<br>String add1(Model model) {<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/add1”;<br>}<br>@GetMapping(“/edit1/{cid}”)<br>String edit1(@PathVariable(“cid”) Long cid, Model model) {<br>ContentDO bContentDO = bContentService.get(cid);<br>model.addAttribute(“bContent”, bContentDO);<br>Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();<br>params.put(“deleted”,0);<br>List<CategoryInfoDO> categoryInfoList = categoryInfoService.list(params);<br>model.addAttribute(“categoryInfoList”, categoryInfoList);<br>return “blog/bContent/edit1”;<br>}<br>@ResponseBody<br>@PostMapping(“/save”)<br>public R save(ContentDO bContent) {</p><pre><code>  if (bContent.getAllowComment() == null) &#123;     bContent.setAllowComment(0);  &#125;  if (bContent.getAllowFeed() == null) &#123;     bContent.setAllowFeed(0);  &#125;  if(null==bContent.getType()) &#123;     bContent.setType(&quot;article&quot;);  &#125;  bContent.setGtmCreate(new Date());  bContent.setGtmModified(new Date());  int count;  if (bContent.getCid() == null || &quot;&quot;.equals(bContent.getCid())) &#123;     bContent.setCreated(getUserId());     count = bContentService.save(bContent);  &#125; else &#123;     count = bContentService.update(bContent);  &#125;  if (count &gt; 0) &#123;     return R.ok().put(&quot;cid&quot;, bContent.getCid());  &#125;  return R.error();</code></pre><p>}<br>@ResponseBody<br>@RequestMapping(“/update”)<br>public R update( ContentDO bContent) {</p><pre><code>  bContent.setGtmCreate(new Date());  bContentService.update(bContent);  return R.ok();</code></pre><p>}<br>@PostMapping(“/remove”)<br>@ResponseBody<br>public R remove(Long id) {</p><pre><code>  if (bContentService.remove(id) &gt; 0) &#123;     return R.ok();  &#125;  return R.error();</code></pre><p>}<br>@PostMapping(“/batchRemove”)<br>@ResponseBody<br>public R remove(@RequestParam(“ids[]”) Long[] cids) {</p><pre><code>  bContentService.batchRemove(cids);  return R.ok();</code></pre><p>}<br>}</p>]]></content>
      
      
      <categories>
          
          <category> 杂物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/2022/11/10/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/10/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="2022-11-10-天气晴"><a href="#2022-11-10-天气晴" class="headerlink" title="2022-11-10 天气晴"></a>2022-11-10 天气晴</h2><p>买了服务器和域名，贫穷的我雪上加霜。<br>论文进度++<br>程序完善++<br>金币–</p>]]></content>
      
      
      <categories>
          
          <category> 杂物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%B9%9D%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%B9%9D%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="太难了啊"><a href="#太难了啊" class="headerlink" title="太难了啊"></a>太难了啊</h2><p>完成了博客的一部分内容，论文进度无。<br>工作也不好找，麻了。</p>]]></content>
      
      
      <categories>
          
          <category> 杂物 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VUE</title>
      <link href="/2022/11/09/%E7%AC%AC%E5%85%AB%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E5%85%AB%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="还没写"><a href="#还没写" class="headerlink" title="还没写"></a>还没写</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>js</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%B8%83%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>1、typeof + 变量名<br>2、prompt 取到的内容是 string 类型的<br>3、转换字符串型<br>变量名.tostring()<br>变量名+’‘ (推荐)<br>4、转换数字型<br>parselnt(string)，能把字符串取整输出，会去掉 px 单位<br>parseFloat(string)<br>string-0 运算符起转换效果(+-*/)</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>1、== 默认转换数据类型<br>2、逻辑与短路运算<br>如果表达式 1 为真 则返回表达式 2<br>如果表达式 1 为假 则返回表达式 1<br>3、逻辑或短路运算<br>如果表达式 1 为真 则返回表达式 1<br>如果表达式 1 为假 则返回表达式 2</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>1、arguments 函数内部的一个属性，是一个存放所有实参的数组<br>2、匿名函数定义： var fn = function(){} fn 是变量名不是函数名</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>1、定义全局变量，特殊情况：在函数内部没有声明直接赋值的变量也属于全局变量<br>2、作用域链：内部函数访问外部函数的变量，采取链式访问，就近原则</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>1、变量(函数)提升到当前作用域的最前端<br>2、面试题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f1();</span><br><span class="line">console.log(c);</span><br><span class="line">console.log(b);</span><br><span class="line">console.log(a);</span><br><span class="line">function f1() &#123;</span><br><span class="line">    var a = b = c = 9;</span><br><span class="line">    //var a = 9;b=9;c=9</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>1、构造函数语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function 构造函数名(值,) &#123;</span><br><span class="line">    this.属性 = 值;</span><br><span class="line">    this.方法 = function(形参) &#123;&#125;</span><br><span class="line">&#125;//定义</span><br><span class="line">new 构造函数名();//调用</span><br></pre></td></tr></table></figure><p>2、遍历对象</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for(var k in obj) &#123;</span><br><span class="line">    console.log(k);//属性名</span><br><span class="line">    console.log(obj[k]);//属性值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、var date = new Date(‘20222-7-2 8:8:8’);<br>4、var date1 = +new Date(); // 返回距离 1970.1.1 的总毫秒数<br>H5 语法:Date.now()<br>案例：倒计时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">        function countDown(time) &#123;</span><br><span class="line">            var now = +new Date();</span><br><span class="line">            var input = +new Date(time);</span><br><span class="line">            var t = (input - now) / 1000;</span><br><span class="line">            var day = parseInt(t / 60 / 60 / 24);</span><br><span class="line">            day = day == 0 ? &#x27;0&#x27; + day : day;</span><br><span class="line">            var hour = parseInt(t / 60 / 60 % 24);</span><br><span class="line">            hour = hour == 0 ? &#x27;0&#x27; + hour : hour;</span><br><span class="line">            var min = parseInt(t / 60 % 60);</span><br><span class="line">            min = min == 0 ? &#x27;0&#x27; + min : min;</span><br><span class="line">            var sec = parseInt(t % 60);</span><br><span class="line">            sec = sec == 0 ? &#x27;0&#x27; + sec : sec;</span><br><span class="line">            var res = day + &#x27;天:&#x27; + hour + &#x27;小时:&#x27; + min + &#x27;分钟:&#x27; + sec+&#x27;秒&#x27;;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(countDown(&#x27;2022-7-2 18:0:0&#x27;));</span><br><span class="line">数组对象</span><br></pre></td></tr></table></figure><p>5、arr instanceof Array 运算符 检测是否为数组<br>H5 语法:Array.isArray(arr)<br>6、arr.push() 尾部添加，返回长度<br>arr.unshift() 头部添加，返回长度<br>arr.pop() 尾部删除，返回删除元素<br>arr.shift() 头部删除，返回删除元素<br>7、arr.sort()</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.sort(function(a,b)&#123;</span><br><span class="line">    return a-b;//降序：b-a</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>8、arr.indexOf()<br>案例：去重</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var arr = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;a&#x27;];</span><br><span class="line"></span><br><span class="line">        function checkDouble(arr) &#123;</span><br><span class="line">            var newArr = [];</span><br><span class="line">            for (var i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">                if (newArr.indexOf(arr[i]) == -1) newArr.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            return newArr;</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(checkDouble(arr));</span><br></pre></td></tr></table></figure><p>9、arr.toString() arr.join(分隔符)<br>10、arr.splice() 删除<br>11、arr.concat() 合并</p><h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>1、str.indexOf(c,start)<br>案例：统计重复字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abcdoedefgoefdoeafao&#x27;;</span><br><span class="line">        var index = str.indexOf(&#x27;o&#x27;);</span><br><span class="line">        var cnt = 0;</span><br><span class="line">        while (index != -1) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            console.log(index);</span><br><span class="line">            index = str.indexOf(&#x27;o&#x27;, index + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        console.log(cnt);</span><br></pre></td></tr></table></figure><p>2、str.charAt(index) 返回该位置的元素<br>str.charCodeAt(index) 返回对应的 ASCII 码<br>案例：统计出现最多的字符和次数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var str = &#x27;abcdoodfegoefdeafaeze&#x27;;</span><br><span class="line">        var obj = &#123;&#125;;</span><br><span class="line">        for (var i = 0; i &lt; str.length; i++) &#123;</span><br><span class="line">            var chars = str.charAt(i)</span><br><span class="line">            if (obj[chars]) &#123;</span><br><span class="line">                obj[chars]++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                obj[chars] = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        var max = 0;</span><br><span class="line">        var c = &#x27;&#x27;;</span><br><span class="line">        for (k in obj) &#123;</span><br><span class="line">            if (obj[k] &gt; max) &#123;</span><br><span class="line">                max = obj[k];</span><br><span class="line">                c = k;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        console.log(c);</span><br><span class="line">        console.log(obj[c]);</span><br></pre></td></tr></table></figure><p>3、str.substr(start,length)<br>str.slice(startindex,endindex)<br>str.split(‘分隔符’) 字符串转换成数组</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>css</title>
      <link href="/2022/11/09/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E5%85%AD%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="web-应用课-css"><a href="#web-应用课-css" class="headerlink" title="web 应用课: css"></a>web 应用课: css</h2><h2 id="一-样式定义方式"><a href="#一-样式定义方式" class="headerlink" title="一. 样式定义方式"></a>一. 样式定义方式</h2><h3 id="内部样式表"><a href="#内部样式表" class="headerlink" title="内部样式表:"></a>内部样式表:</h3><p>一般写在 head, 但也可以写在任意位置, 只要在应用区域之前即可</p><h3 id="外部样式表"><a href="#外部样式表" class="headerlink" title="外部样式表"></a>外部样式表</h3><p>在 css 文件:<br>p {<br>width: 50px;<br>}</p><p>.big {<br>width: 500px;<br>}<br>在 html 文件:<br>注意: 这里的 href, 最好自己手打, 直接复制容易出现 css 外部样式怎么都不显示的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line"></span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/style.css&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="二-选择器"><a href="#二-选择器" class="headerlink" title="二. 选择器"></a>二. 选择器</h2><h3 id="1-伪类选择器"><a href="#1-伪类选择器" class="headerlink" title="1.伪类选择器:"></a>1.伪类选择器:</h3><p>应该叫状态选择器:</p><p>有没有被选中, 有没有被点击, 有没有被长按, 等等</p><p>位置,</p><p>当前链接链接跳转</p><h3 id="2-通配符选择器"><a href="#2-通配符选择器" class="headerlink" title="2. 通配符选择器:"></a>2. 通配符选择器:</h3><p>应该叫属性选择器: 查看是否具有某些属性, 也可以是选择全部</p><h3 id="3-伪元素选择器"><a href="#3-伪元素选择器" class="headerlink" title="3. .伪元素选择器:"></a>3. .伪元素选择器:</h3><p>应该叫内容选择器: 修改添加第一或者最后一个字, 等等</p><h2 id="三-颜色"><a href="#三-颜色" class="headerlink" title="三. 颜色"></a>三. 颜色</h2><p>屏幕颜色都是由 R(红)G(绿)B(蓝)组成, 每一种取 0<del>255, 16 位数(二进制)可以拆成两个 8 位数(0</del>16),</p><p>11, 12, 13, 14, 15 分别用 A, B, C, D, E, F 表示, 总共 6 位</p><h2 id="四-文本及其他-块"><a href="#四-文本及其他-块" class="headerlink" title="四. 文本及其他(块)"></a>四. 文本及其他(块)</h2><h3 id="1-利用行高实现垂直居中"><a href="#1-利用行高实现垂直居中" class="headerlink" title="1. 利用行高实现垂直居中:"></a>1. 利用行高实现垂直居中:</h3><p>每个字都是写在每一行中间, 当设置行高等于字所在 div(块)的高度时, 便可实现居中</p><h3 id="2-实现多个样式"><a href="#2-实现多个样式" class="headerlink" title="2. 实现多个样式:"></a>2. 实现多个样式:</h3><p>逗号隔开, 分号结尾, 这里举例文字阴影:</p><p>div{<br>text-show: -5px -5px 2px grey,<br>5px -5px 2px red;<br>}</p><h3 id="3-em-与-的区别"><a href="#3-em-与-的区别" class="headerlink" title="3. em 与 % 的区别:"></a>3. em 与 % 的区别:</h3><p>%如果是最外的 div 那么, 此时父元素指的是 body</p><p>在文本中区别不大, 但是在”块”中区别比较大, 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;height: 5em; background-color: aqua;&quot;&gt;</span><br><span class="line">        第一</span><br><span class="line">        &lt;div style=&quot;height: 200%; background-color: black;&quot;&gt;</span><br><span class="line">            第二</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div style=&quot;height: 5em; background-color: aqua;&quot;&gt;</span><br><span class="line">        第一</span><br><span class="line">        &lt;div style=&quot;height: 2em; background-color: black;&quot;&gt;</span><br><span class="line">            第二</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="五-字体"><a href="#五-字体" class="headerlink" title="五. 字体"></a>五. 字体</h2><h2 id="六-背景"><a href="#六-背景" class="headerlink" title="六. 背景"></a>六. 背景</h2><h3 id="1-可以添加多张图片"><a href="#1-可以添加多张图片" class="headerlink" title="1. 可以添加多张图片:"></a>1. 可以添加多张图片:</h3><p>添加逗号隔开</p><h3 id="2-设置背景图片大小"><a href="#2-设置背景图片大小" class="headerlink" title="2. 设置背景图片大小:"></a>2. 设置背景图片大小:</h3><p>可以用百分比, 默认位置是左上角;</p><p>全覆盖: cover: 宽高取 max, contain: 宽高取 min, %: 自动拉伸</p><p>设置透明度: 除了 rgba, 还可以设置 opacity 的值</p><h2 id="七-边框"><a href="#七-边框" class="headerlink" title="七. 边框"></a>七. 边框</h2><h3 id="1-分别设置各边"><a href="#1-分别设置各边" class="headerlink" title="1.分别设置各边:"></a>1.分别设置各边:</h3><p>四个参数: 对应上右下左</p><p>两个参数: 对应上右, 没有的取对边</p><p>三个参数:对应上右下, 没有的取对边</p><p>一个参数: 指全部</p><h3 id="2-设置圆角"><a href="#2-设置圆角" class="headerlink" title="2. 设置圆角:"></a>2. 设置圆角:</h3><p>多少 px, 是指以多少 px 为半径, %同理; 四角顺序则是:0, 1, 2, 3</p><h2 id="八-元素展示格式"><a href="#八-元素展示格式" class="headerlink" title="八. 元素展示格式"></a>八. 元素展示格式</h2><h2 id="九-内边距与外边距"><a href="#九-内边距与外边距" class="headerlink" title="九. 内边距与外边距"></a>九. 内边距与外边距</h2><h3 id="1-分别设置各边-1"><a href="#1-分别设置各边-1" class="headerlink" title="1.分别设置各边:"></a>1.分别设置各边:</h3><p>四个参数: 对应上右下左</p><p>两个参数: 对应上右, 没有的取对边</p><p>三个参数:对应上右下, 没有的取对边</p><p>一个参数: 指全部</p><p>参数如果是%, 则表示的是父元素宽度的百分比</p><h3 id="2-外边距-“塌陷”解决方法"><a href="#2-外边距-“塌陷”解决方法" class="headerlink" title="2.外边距 “塌陷”解决方法:"></a>2.外边距 “塌陷”解决方法:</h3><p>(1)父元素没有上边框和 padding 时，后代元素的 margin-top 会溢出:<br>① border-top: 1px solid;</p><p>② padding-top: 1px;</p><p>③ overflow hiden;</p><p>④ 加上一个伪元素: (最佳)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.div-outer::before&#123;</span><br><span class="line">    content: &quot;&quot;;</span><br><span class="line">    display: table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)相邻上下元素, 上面元素有下边的外边距, 下面元素有上边的外边距:<br>如图: 上下边距会取 max</p><p>解决方法: 定好以下边距为主, 即上下设置边距, 仅设置下边距</p><p>左右不会出现这种重叠的情况, 只会相加</p><h3 id="3-外边距-auto-实现不了竖直居中"><a href="#3-外边距-auto-实现不了竖直居中" class="headerlink" title="3. 外边距 auto 实现不了竖直居中:"></a>3. 外边距 auto 实现不了竖直居中:</h3><p>margin: auto;</p><p>四方向都用 auto, 只能实现水平居中</p><h3 id="4-矩形默认模型下-宽度计算方法"><a href="#4-矩形默认模型下-宽度计算方法" class="headerlink" title="4. 矩形默认模型下, 宽度计算方法:"></a>4. 矩形默认模型下, 宽度计算方法:</h3><p>宽度 = 块宽度 + 内边距 + 边框</p><p>width = content + padding + border</p><h2 id="十-盒子模型"><a href="#十-盒子模型" class="headerlink" title="十. 盒子模型"></a>十. 盒子模型</h2><h2 id="十一-位置"><a href="#十一-位置" class="headerlink" title="十一. 位置"></a>十一. 位置</h2><p>sticky:<br>课程视频: 47 : 36 ~ 50 : 50</p><h2 id="十二-浮动"><a href="#十二-浮动" class="headerlink" title="十二. 浮动"></a>十二. 浮动</h2><h3 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用:"></a>1. 作用:</h3><p>与 display: inline-block;的功能一样, 都是让 ‘块’ 自动补齐一行;</p><p>但是与 display: inline-block;不同的是,</p><p>display: inline-block;块与块之间会有空隙:</p><p>而 float 则不会有这样的影响:</p><h3 id="2-float-参数"><a href="#2-float-参数" class="headerlink" title="2. float 参数:"></a>2. float 参数:</h3><p>left: 浮动, 且左对齐</p><p>right: 浮动, 且右对齐</p><h3 id="3-clear"><a href="#3-clear" class="headerlink" title="3. clear:"></a>3. clear:</h3><p>某个 ‘块’ 受到其他浮动块影响时使用</p><p>clear 前: clear 后:</p><h2 id="十三-flex-布局"><a href="#十三-flex-布局" class="headerlink" title="十三. flex 布局"></a>十三. flex 布局</h2><h3 id="1-css-默认摆放"><a href="#1-css-默认摆放" class="headerlink" title="1. css 默认摆放:"></a>1. css 默认摆放:</h3><p>从左到右沿主轴摆放, 不换行.</p><p>如下: 从左到右称为主轴, 从上到下称为交叉轴 (块轴)(侧轴)</p><h3 id="2-align-items"><a href="#2-align-items" class="headerlink" title="2. align-items:"></a>2. align-items:</h3><p>(1) flex-start: (上对齐)</p><p>(2) flex-end: (下对齐)<br>(3)center: (所有行均匀分布在中间)</p><h3 id="3-align-items-与-align-content-的区别"><a href="#3-align-items-与-align-content-的区别" class="headerlink" title="3. align-items 与 align-content 的区别:"></a>3. align-items 与 align-content 的区别:</h3><p>记忆: items 行与行均匀分布, content 则不均匀</p><p>体现如下:</p><p>(1) items: content:</p><p>(2) items:</p><p>content: (居中效果消失)</p><h3 id="4-flex-实现水平-竖直居中"><a href="#4-flex-实现水平-竖直居中" class="headerlink" title="4. flex 实现水平, 竖直居中:"></a>4. flex 实现水平, 竖直居中:</h3><p>(1) 之前办法:</p><p>margin: 0 auto; /<em>水平居中</em>/<br>position: relative;<br>top: 50%;<br>transfrom: translateY(50%); /<em>竖直居中</em>/<br>原理:</p><p>(2) flex 实现:</p><p>display: flex;<br>justify-content: center;<br>align-items: center;</p><h3 id="5-flex-grow-与-flex-shrink"><a href="#5-flex-grow-与-flex-shrink" class="headerlink" title="5. flex-grow 与 flex-shrink:"></a>5. flex-grow 与 flex-shrink:</h3><p>表示放大与缩小速度, 与比例有关, 取非负值, 小数也可以;</p><p>例如 flex-grow 红块 1,绿块 0.1:</p><h3 id="6-flex-basis"><a href="#6-flex-basis" class="headerlink" title="6. flex-basis:"></a>6. flex-basis:</h3><p>调初始宽度的大小</p><h2 id="十四-响应式布局"><a href="#十四-响应式布局" class="headerlink" title="十四. 响应式布局"></a>十四. 响应式布局</h2><h3 id="1-当用计算去算-width-的-时"><a href="#1-当用计算去算-width-的-时" class="headerlink" title="1. 当用计算去算 width 的%时:"></a>1. 当用计算去算 width 的%时:</h3><p>width: calc(100% * x / y)</p><p>x: 占多少份, y: 一共分多少份</p><h3 id="2-使用-Bootstrap"><a href="#2-使用-Bootstrap" class="headerlink" title="2. 使用 Bootstrap"></a>2. 使用 Bootstrap</h3><p>(1) 下载并解压包</p><p>(2) 将内容写到<form></form>里</p><p>(3) 将一行分为 12 份 (因为 12 的因数比较多), 然后可以在 div 里写 class=”xx-n”,</p><p>xx 指大小, 有 xs, sm, md, lg, xl; 对应屏幕大小</p><p>n 指占多少份</p><p>(4) 例如:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;div class=&quot;mb-3&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;exampleInputEmail1&quot; class=&quot;form-label&quot;&gt;Email address&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;email&quot; class=&quot;form-control&quot; id=&quot;exampleInputEmail1&quot; aria-describedby=&quot;emailHelp&quot;&gt;</span><br><span class="line">    &lt;div id=&quot;emailHelp&quot; class=&quot;form-text&quot;&gt;We&#x27;ll never share your email with anyone else.&lt;/div&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;mb-3&quot;&gt;</span><br><span class="line">    &lt;label for=&quot;exampleInputPassword1&quot; class=&quot;form-label&quot;&gt;Password&lt;/label&gt;</span><br><span class="line">    &lt;input type=&quot;password&quot; class=&quot;form-control&quot; id=&quot;exampleInputPassword1&quot;&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;div class=&quot;mb-3 form-check&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;checkbox&quot; class=&quot;form-check-input&quot; id=&quot;exampleCheck1&quot;&gt;</span><br><span class="line">    &lt;label class=&quot;form-check-label&quot; for=&quot;exampleCheck1&quot;&gt;Check me out&lt;/label&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  &lt;button type=&quot;submit&quot; class=&quot;btn btn-primary&quot;&gt;Submit&lt;/button&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>html</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%BA%94%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="没必要"><a href="#没必要" class="headerlink" title="没必要"></a>没必要</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-tmux和vim</title>
      <link href="/2022/11/09/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E5%9B%9B%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-tmux"><a href="#1-tmux" class="headerlink" title="1.tmux"></a>1.tmux</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">功能：</span><br><span class="line">    (1) 分屏。</span><br><span class="line">    (2) 允许断开Terminal连接后，继续运行进程。</span><br><span class="line">结构：</span><br><span class="line">    一个tmux可以包含多个session，一个session可以包含多个window，一个window可以包含多个pane。</span><br><span class="line">    实例：</span><br><span class="line">        tmux:</span><br><span class="line">            session 0:</span><br><span class="line">                window 0:</span><br><span class="line">                    pane 0</span><br><span class="line">                    pane 1</span><br><span class="line">                    pane 2</span><br><span class="line">                    ...</span><br><span class="line">                window 1</span><br><span class="line">                window 2</span><br><span class="line">                ...</span><br><span class="line">            session 1</span><br><span class="line">            session 2</span><br><span class="line">            ...</span><br><span class="line">操作：</span><br><span class="line">    (1) tmux：新建一个session，其中包含一个window，window中包含一个pane，pane里打开了一个shell对话框。</span><br><span class="line">    (2) 按下Ctrl + a后手指松开，然后按%：将当前pane左右平分成两个pane。</span><br><span class="line">    (3) 按下Ctrl + a后手指松开，然后按&quot;（注意是双引号&quot;）：将当前pane上下平分成两个pane。</span><br><span class="line">    (4) Ctrl + d：关闭当前pane；如果当前window的所有pane均已关闭，则自动关闭window；如果当前session的所有window均已关闭，则自动关闭session。</span><br><span class="line">    (5) 鼠标点击可以选pane。</span><br><span class="line">    (6) 按下ctrl + a后手指松开，然后按方向键：选择相邻的pane。</span><br><span class="line">    (7) 鼠标拖动pane之间的分割线，可以调整分割线的位置。</span><br><span class="line">    (8) 按住ctrl + a的同时按方向键，可以调整pane之间分割线的位置。</span><br><span class="line">    (9) 按下ctrl + a后手指松开，然后按z：将当前pane全屏/取消全屏。</span><br><span class="line">    (10) 按下ctrl + a后手指松开，然后按d：挂起当前session。</span><br><span class="line">    (11) tmux a：打开之前挂起的session。</span><br><span class="line">    (12) 按下ctrl + a后手指松开，然后按s：选择其它session。</span><br><span class="line">        方向键 —— 上：选择上一项 session/window/pane</span><br><span class="line">        方向键 —— 下：选择下一项 session/window/pane</span><br><span class="line">        方向键 —— 右：展开当前项 session/window</span><br><span class="line">        方向键 —— 左：闭合当前项 session/window</span><br><span class="line">    (13) 按下Ctrl + a后手指松开，然后按c：在当前session中创建一个新的window。</span><br><span class="line">    (14) 按下Ctrl + a后手指松开，然后按w：选择其他window，操作方法与(12)完全相同。</span><br><span class="line">    (15) 按下Ctrl + a后手指松开，然后按PageUp：翻阅当前pane内的内容。</span><br><span class="line">    (16) 鼠标滚轮：翻阅当前pane内的内容。</span><br><span class="line">    (17) 在tmux中选中文本时，需要按住shift键。（仅支持Windows和Linux，不支持Mac，不过该操作并不是必须的，因此影响不大）</span><br><span class="line">    (18) tmux中复制/粘贴文本的通用方式：</span><br><span class="line">        (1) 按下Ctrl + a后松开手指，然后按[</span><br><span class="line">        (2) 用鼠标选中文本，被选中的文本会被自动复制到tmux的剪贴板</span><br><span class="line">        (3) 按下Ctrl + a后松开手指，然后按]，会将剪贴板中的内容粘贴到光标处</span><br></pre></td></tr></table></figure><p>2.vim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">功能：</span><br><span class="line">    (1) 命令行模式下的文本编辑器。</span><br><span class="line">    (2) 根据文件扩展名自动判别编程语言。支持代码缩进、代码高亮等功能。</span><br><span class="line">    (3) 使用方式：vim filename</span><br><span class="line">        如果已有该文件，则打开它。</span><br><span class="line">        如果没有该文件，则打开个一个新的文件，并命名为filename</span><br><span class="line">模式：</span><br><span class="line">    (1) 一般命令模式</span><br><span class="line">        默认模式。命令输入方式：类似于打游戏放技能，按不同字符，即可进行不同操作。可以复制、粘贴、删除文本等。</span><br><span class="line">    (2) 编辑模式</span><br><span class="line">        在一般命令模式里按下i，会进入编辑模式。</span><br><span class="line">        按下ESC会退出编辑模式，返回到一般命令模式。</span><br><span class="line">    (3) 命令行模式</span><br><span class="line">        在一般命令模式里按下:/?三个字母中的任意一个，会进入命令行模式。命令行在最下面。</span><br><span class="line">        可以查找、替换、保存、退出、配置编辑器等。</span><br><span class="line">操作：</span><br><span class="line">    (1) i：进入编辑模式</span><br><span class="line">    (2) ESC：进入一般命令模式</span><br><span class="line">    (3) h 或 左箭头键：光标向左移动一个字符</span><br><span class="line">    (4) j 或 向下箭头：光标向下移动一个字符</span><br><span class="line">    (5) k 或 向上箭头：光标向上移动一个字符</span><br><span class="line">    (6) l 或 向右箭头：光标向右移动一个字符</span><br><span class="line">    (7) n&lt;Space&gt;：n表示数字，按下数字后再按空格，光标会向右移动这一行的n个字符</span><br><span class="line">    (8) 0 或 功能键[Home]：光标移动到本行开头</span><br><span class="line">    (9) $ 或 功能键[End]：光标移动到本行末尾</span><br><span class="line">    (10) G：光标移动到最后一行</span><br><span class="line">    (11) :n 或 nG：n为数字，光标移动到第n行</span><br><span class="line">    (12) gg：光标移动到第一行，相当于1G</span><br><span class="line">    (13) n&lt;Enter&gt;：n为数字，光标向下移动n行</span><br><span class="line">    (14) /word：向光标之下寻找第一个值为word的字符串。</span><br><span class="line">    (15) ?word：向光标之上寻找第一个值为word的字符串。</span><br><span class="line">    (16) n：重复前一个查找操作</span><br><span class="line">    (17) N：反向重复前一个查找操作</span><br><span class="line">    (18) :n1,n2s/word1/word2/g：n1与n2为数字，在第n1行与n2行之间寻找word1这个字符串，并将该字符串替换为word2</span><br><span class="line">    (19) :1,$s/word1/word2/g：将全文的word1替换为word2</span><br><span class="line">    (20) :1,$s/word1/word2/gc：将全文的word1替换为word2，且在替换前要求用户确认。</span><br><span class="line">    (21) v：选中文本</span><br><span class="line">    (22) d：删除选中的文本</span><br><span class="line">    (23) dd: 删除当前行</span><br><span class="line">    (24) y：复制选中的文本</span><br><span class="line">    (25) yy: 复制当前行</span><br><span class="line">    (26) p: 将复制的数据在光标的下一行/下一个位置粘贴</span><br><span class="line">    (27) u：撤销</span><br><span class="line">    (28) Ctrl + r：取消撤销</span><br><span class="line">    (29) 大于号 &gt;：将选中的文本整体向右缩进一次</span><br><span class="line">    (30) 小于号 &lt;：将选中的文本整体向左缩进一次</span><br><span class="line">    (31) :w 保存</span><br><span class="line">    (32) :w! 强制保存</span><br><span class="line">    (33) :q 退出</span><br><span class="line">    (34) :q! 强制退出</span><br><span class="line">    (35) :wq 保存并退出</span><br><span class="line">    (36) :set paste 设置成粘贴模式，取消代码自动缩进</span><br><span class="line">    (37) :set nopaste 取消粘贴模式，开启代码自动缩进</span><br><span class="line">    (38) :set nu 显示行号</span><br><span class="line">    (39) :set nonu 隐藏行号</span><br><span class="line">    (40) gg=G：将全文代码格式化</span><br><span class="line">    (41) :noh 关闭查找关键词高亮</span><br><span class="line">    (42) Ctrl + q：当vim卡死时，可以取消当前正在执行的命令</span><br><span class="line">异常处理：</span><br><span class="line">    每次用vim编辑文件时，会自动创建一个.filename.swp的临时文件。</span><br><span class="line">    如果打开某个文件时，该文件的swp文件已存在，则会报错。此时解决办法有两种：</span><br><span class="line">        (1) 找到正在打开该文件的程序，并退出</span><br><span class="line">        (2) 直接删掉该swp文件即可</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux-常用文件管理命令</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用文件管理命令"><a href="#1-常用文件管理命令" class="headerlink" title="1.常用文件管理命令"></a>1.常用文件管理命令</h2><h3 id="1-Ctrl-c-取消命令，并且换行"><a href="#1-Ctrl-c-取消命令，并且换行" class="headerlink" title="(1).Ctrl + c : 取消命令，并且换行"></a>(1).<code>Ctrl + c</code> : 取消命令，并且换行</h3><h3 id="2-Ctrl-u-清空本行命令"><a href="#2-Ctrl-u-清空本行命令" class="headerlink" title="(2).Ctrl + u : 清空本行命令"></a>(2).<code>Ctrl + u</code> : 清空本行命令</h3><h3 id="3-tab-可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项"><a href="#3-tab-可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项" class="headerlink" title="(3).tab : 可以补全命令和文件名，如果补全不了快速按两下tab键，可以显示备选选项"></a>(3).<code>tab</code> : 可以补全命令和文件名，如果补全不了快速按两下<code>tab</code>键，可以显示备选选项</h3><h3 id="4-ls-列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件"><a href="#4-ls-列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件" class="headerlink" title="(4).ls :列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件"></a>(4).<code>ls</code> :列出当前目录下所有文件，蓝色的是文件夹，白色的是普通文件，绿色的是可执行文件</h3><blockquote><p>●ㅤ<code>ls -a</code> : 查看所有文件包括隐藏文件（以<code>.</code>开头的文件就是隐藏文件）<br>●ㅤ<code>ls -A</code> : 当前目录，不显示上层目录<br>●ㅤ<code>ls -l</code> : 查看当前路径下文件详细信息</p></blockquote><h3 id="5-pwd-显示当前路径"><a href="#5-pwd-显示当前路径" class="headerlink" title="(5).pwd : 显示当前路径"></a>(5).<code>pwd</code> : 显示当前路径</h3><h3 id="6-cd-XXX-进入XXX目录下，cd-返回上层目录"><a href="#6-cd-XXX-进入XXX目录下，cd-返回上层目录" class="headerlink" title="(6).cd XXX : 进入XXX目录下，cd ..返回上层目录"></a>(6).<code>cd XXX</code> : 进入<code>XXX</code>目录下，<code>cd ..</code>返回上层目录</h3><blockquote><p>●ㅤ<code>.</code>：当前目录 <code>..</code>：上级目录<br>●ㅤ<code>~</code>：家目录，回到路径<code>/home/acs</code>下<br>●ㅤ<code>cd -</code>：返回改变路径前的路径，比如当前在<code>/home/acs/homework</code>然后<code>cd** **/</code>这个时候就处于<code>/</code>目录下，然后<code>cd -</code>就会回到改变路径前的路径也就是<code>/home/acs/homework</code></p></blockquote><h3 id="7-cp-a-XXX-YYY-将XXX文件复制到YYY，XXX和YYY可以是同一个路径，比如-dir-c-a-txt，表示上层目录下的dir-c文件夹下的文件a-txt"><a href="#7-cp-a-XXX-YYY-将XXX文件复制到YYY，XXX和YYY可以是同一个路径，比如-dir-c-a-txt，表示上层目录下的dir-c文件夹下的文件a-txt" class="headerlink" title="(7).cp a/XXX YYY : 将XXX文件复制到YYY，XXX和YYY可以是同一个路径，比如../dir_c/a.txt，表示上层目录下的dir_c文件夹下的文件a.txt"></a>(7).<code>cp a/XXX YYY</code> : 将<code>XXX</code>文件复制到<code>YYY</code>，<code>XXX</code>和<code>YYY</code>可以是同一个路径，比如<code>../dir_c/a.txt</code>，表示上层目录下的<code>dir_c</code>文件夹下的文件<code>a.txt</code></h3><blockquote><p>●ㅤ<code>cp XXX YYY -r</code>：将<code>XXX</code>目录（文件夹）复制到<code>YYY</code>下<br>●ㅤ<code>cp a.txt ../b.txt</code>：非当前路径重命名方法</p></blockquote><h3 id="8-mkdir-XXX：创建目录（文件夹）XXX"><a href="#8-mkdir-XXX：创建目录（文件夹）XXX" class="headerlink" title="(8).mkdir XXX：创建目录（文件夹）XXX"></a>(8).<code>mkdir XXX</code>：创建目录（文件夹）<code>XXX</code></h3><blockquote><p>●ㅤ<code>mkdir -p</code> : 如果文件夹不存在，则创建</p></blockquote><h3 id="9-rm-XXX：删除普通文件；-rm-XXX-r：删除文件夹"><a href="#9-rm-XXX：删除普通文件；-rm-XXX-r：删除文件夹" class="headerlink" title="(9).rm XXX：删除普通文件； rm XXX -r：删除文件夹"></a>(9).<code>rm XXX</code>：删除普通文件； <code>rm XXX -r</code>：删除文件夹</h3><blockquote><p>●<code>rm *.txt</code> : 支持正则表达式，删除所有<code>.txt</code>类型文件<br>●<code>rm *</code> : 删除所有文件(不包括文件夹)<br>●<code>rm * -r</code> : 删除所有文件夹</p></blockquote><h3 id="10-mv-XXX-YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令"><a href="#10-mv-XXX-YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令" class="headerlink" title="(10).mv XXX YYY：将XXX文件移动到YYY下，和cp命令一样，XXX和YYY可以是同一个路径；重命名也是用这个命令"></a>(10).<code>mv XXX YYY</code>：将<code>XXX</code>文件移动到<code>YYY</code>下，和<code>cp</code>命令一样，<code>XXX</code>和<code>YYY</code>可以是同一个路径；重命名也是用这个命令</h3><blockquote><p>●<code>mv a.txt ../b.txt</code> : 非当前路径移动方法</p></blockquote><h3 id="11-touch-XXX-创建一个文件"><a href="#11-touch-XXX-创建一个文件" class="headerlink" title="(11).touch XXX : 创建一个文件"></a>(11).<code>touch XXX</code> : 创建一个文件</h3><h3 id="12-cat-XXX-展示文件-XXX-中的内容"><a href="#12-cat-XXX-展示文件-XXX-中的内容" class="headerlink" title="(12).cat XXX : 展示文件 XXX 中的内容"></a>(12).<code>cat XXX</code> : 展示文件 XXX 中的内容</h3><h3 id="13-复制文本-windows-Linux下：Ctrl-insert，Mac下：command-c"><a href="#13-复制文本-windows-Linux下：Ctrl-insert，Mac下：command-c" class="headerlink" title="(13).复制文本 : windows/Linux下：Ctrl + insert，Mac下：command + c"></a>(13).复制文本 : <code>windows/Linux</code>下：<code>Ctrl + insert</code>，<code>Mac</code>下：<code>command + c</code></h3><h3 id="14-粘贴文本-windows-Linux下：Shift-insert，Mac下：command-v"><a href="#14-粘贴文本-windows-Linux下：Shift-insert，Mac下：command-v" class="headerlink" title="(14).粘贴文本 : windows/Linux下：Shift + insert，Mac下：command + v"></a>(14).粘贴文本 : <code>windows/Linux</code>下：<code>Shift + insert</code>，<code>Mac</code>下：<code>command + v</code></h3><h3 id="15-history-查看历史输入指令"><a href="#15-history-查看历史输入指令" class="headerlink" title="(15).history : 查看历史输入指令"></a>(15).<code>history</code> : 查看历史输入指令</h3><h3 id="16-tree-以树形显示文件目录结构"><a href="#16-tree-以树形显示文件目录结构" class="headerlink" title="(16).tree : 以树形显示文件目录结构"></a>(16).<code>tree</code> : 以树形显示文件目录结构</h3><h2 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h2><h3 id="0-进入-homework-0-文件夹，分别创建文件夹-dir-a-dir-b-dir-c"><a href="#0-进入-homework-0-文件夹，分别创建文件夹-dir-a-dir-b-dir-c" class="headerlink" title="(0) 进入 homework_0 文件夹，分别创建文件夹 dir_a, dir_b, dir_c"></a>(0) 进入 homework_0 文件夹，分别创建文件夹 dir_a, dir_b, dir_c</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd homework_0</span><br><span class="line">mkdir dir_a dir_b dir_c</span><br></pre></td></tr></table></figure><h3 id="1-进入-homework-1-文件夹，将-a-txt-b-txt-c-txt-分别复制成-a-txt-bak-b-txt-bak-c-txt-bak"><a href="#1-进入-homework-1-文件夹，将-a-txt-b-txt-c-txt-分别复制成-a-txt-bak-b-txt-bak-c-txt-bak" class="headerlink" title="(1) 进入 homework_1 文件夹，将 a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak"></a>(1) 进入 homework_1 文件夹，将 a.txt, b.txt, c.txt 分别复制成: a.txt.bak, b.txt.bak, c.txt.bak</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd homework_1</span><br><span class="line">cp a.txt a.txt.bak</span><br><span class="line">cp b.txt b.txt.bak</span><br><span class="line">cp c.txt c.txt.bak</span><br></pre></td></tr></table></figure><h3 id="2-进入-homework-2-文件夹，将-a-txt-b-txt-c-txt-分别重命名为-a-new-txt-b-new-txt-c-new-txt"><a href="#2-进入-homework-2-文件夹，将-a-txt-b-txt-c-txt-分别重命名为-a-new-txt-b-new-txt-c-new-txt" class="headerlink" title="(2) 进入 homework_2 文件夹，将 a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt"></a>(2) 进入 homework_2 文件夹，将 a.txt, b.txt, c.txt 分别重命名为: a_new.txt, b_new.txt, c_new.txt</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd homework_2</span><br><span class="line">mv a.txt a_new.txt</span><br><span class="line">mv b.txt b_new.txt</span><br><span class="line">mv c.txt c_new.txt</span><br></pre></td></tr></table></figure><h3 id="3-进入-homework-3-文件夹，将-dir-a-文件夹下的-a-txt-b-txt-c-txt-分别移动到文件夹-dir-b-下"><a href="#3-进入-homework-3-文件夹，将-dir-a-文件夹下的-a-txt-b-txt-c-txt-分别移动到文件夹-dir-b-下" class="headerlink" title="(3) 进入 homework_3 文件夹，将 dir_a 文件夹下的 a.txt, b.txt, c.txt 分别移动到文件夹 dir_b 下"></a>(3) 进入 homework_3 文件夹，将 dir_a 文件夹下的 a.txt, b.txt, c.txt 分别移动到文件夹 dir_b 下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd homework_3</span><br><span class="line">mv dir_a/* dir_b/</span><br></pre></td></tr></table></figure><h3 id="4-进入-homework-4-文件夹，将普通文件-a-txt-b-txt-c-txt-删除"><a href="#4-进入-homework-4-文件夹，将普通文件-a-txt-b-txt-c-txt-删除" class="headerlink" title="(4) 进入 homework_4 文件夹，将普通文件 a.txt, b.txt, c.txt 删除"></a>(4) 进入 homework_4 文件夹，将普通文件 a.txt, b.txt, c.txt 删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd homework_4</span><br><span class="line">rm a.txt b.txt c.txt</span><br><span class="line">// rm *</span><br></pre></td></tr></table></figure><h3 id="5-进入-homework-5-文件夹，将文件夹-dir-a-dir-b-dir-c-删除"><a href="#5-进入-homework-5-文件夹，将文件夹-dir-a-dir-b-dir-c-删除" class="headerlink" title="(5) 进入 homework_5 文件夹，将文件夹 dir_a, dir_b, dir_c 删除"></a>(5) 进入 homework_5 文件夹，将文件夹 dir_a, dir_b, dir_c 删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd homework_5</span><br><span class="line">rm dir_a dir_b dir_c -r</span><br><span class="line">// rm * -r</span><br></pre></td></tr></table></figure><h3 id="6-进入-homework-6-文件夹，查看-task-txt-的内容，并按其指示进行操作"><a href="#6-进入-homework-6-文件夹，查看-task-txt-的内容，并按其指示进行操作" class="headerlink" title="(6) 进入 homework_6 文件夹，查看 task.txt 的内容，并按其指示进行操作"></a>(6) 进入 homework_6 文件夹，查看 task.txt 的内容，并按其指示进行操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd homework_6</span><br><span class="line">cat task.txt</span><br><span class="line">mkdir dir_a</span><br><span class="line">mv task.txt dir_a/done.txt</span><br></pre></td></tr></table></figure><h3 id="7-进入-homework-7-文件夹，创建文件夹-dir-0-dir-1-dir-2，将-a-txt-b-txt-c-txt-复制到-dir-0-下，重命名为-a0-txt-b0-txt-c0-txt-将-a-txt-b-txt-c-txt-复制到-dir-1-下，重命名为-a1-txt-b1-txt-c1-txt-将-a-txt-b-txt-c-txt-复制到-dir-2-下，重命名为-a2-txt-b2-txt-c2-txt"><a href="#7-进入-homework-7-文件夹，创建文件夹-dir-0-dir-1-dir-2，将-a-txt-b-txt-c-txt-复制到-dir-0-下，重命名为-a0-txt-b0-txt-c0-txt-将-a-txt-b-txt-c-txt-复制到-dir-1-下，重命名为-a1-txt-b1-txt-c1-txt-将-a-txt-b-txt-c-txt-复制到-dir-2-下，重命名为-a2-txt-b2-txt-c2-txt" class="headerlink" title="(7) 进入 homework_7 文件夹，创建文件夹 dir_0, dir_1, dir_2，将 a.txt, b.txt, c.txt 复制到 dir_0 下，重命名为 a0.txt, b0.txt, c0.txt;将 a.txt, b.txt, c.txt 复制到 dir_1 下，重命名为 a1.txt, b1.txt, c1.txt;将 a.txt, b.txt, c.txt 复制到 dir_2 下，重命名为 a2.txt, b2.txt, c2.txt;"></a>(7) 进入 homework_7 文件夹，创建文件夹 dir_0, dir_1, dir_2，将 a.txt, b.txt, c.txt 复制到 dir_0 下，重命名为 a0.txt, b0.txt, c0.txt;将 a.txt, b.txt, c.txt 复制到 dir_1 下，重命名为 a1.txt, b1.txt, c1.txt;将 a.txt, b.txt, c.txt 复制到 dir_2 下，重命名为 a2.txt, b2.txt, c2.txt;</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cd homework_7</span><br><span class="line">mkdir dir_0 dir_1 dir_2</span><br><span class="line"></span><br><span class="line">cp a.txt dir_0/a0.txt</span><br><span class="line">cp b.txt dir_0/b0.txt</span><br><span class="line">cp c.txt dir_0/c0.txt</span><br><span class="line"></span><br><span class="line">cp a.txt dir_1/a1.txt</span><br><span class="line">cp b.txt dir_1/b1.txt</span><br><span class="line">cp c.txt dir_1/c1.txt</span><br><span class="line"></span><br><span class="line">cp a.txt dir_2/a2.txt</span><br><span class="line">cp b.txt dir_2/b2.txt</span><br><span class="line">cp c.txt dir_2/c2.txt</span><br></pre></td></tr></table></figure><h3 id="8-进入-homework-8-文件夹，分别在-dir-a-dir-b-dir-c-文件夹下查看-task-txt-的内容，并分别按照指示进行操作"><a href="#8-进入-homework-8-文件夹，分别在-dir-a-dir-b-dir-c-文件夹下查看-task-txt-的内容，并分别按照指示进行操作" class="headerlink" title="(8) 进入 homework_8 文件夹，分别在 dir_a, dir_b, dir_c 文件夹下查看 task.txt 的内容，并分别按照指示进行操作"></a>(8) 进入 homework_8 文件夹，分别在 dir_a, dir_b, dir_c 文件夹下查看 task.txt 的内容，并分别按照指示进行操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cd homework_8</span><br><span class="line"></span><br><span class="line">cd dir_a</span><br><span class="line">cat task.txt</span><br><span class="line">rm a.txt</span><br><span class="line"></span><br><span class="line">cd ../dir_b</span><br><span class="line">cat task.txt</span><br><span class="line">mv b.txt b_new.txt</span><br><span class="line"></span><br><span class="line">cd ../dir_c</span><br><span class="line">cat task.txt</span><br><span class="line">cp c.txt c.txt.bak</span><br></pre></td></tr></table></figure><h3 id="9-进入-homework-9-文件夹，将其中所有-txt-类型的文件删除"><a href="#9-进入-homework-9-文件夹，将其中所有-txt-类型的文件删除" class="headerlink" title="(9) 进入 homework_9 文件夹，将其中所有 txt 类型的文件删除"></a>(9) 进入 homework_9 文件夹，将其中所有 txt 类型的文件删除</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd homework_9</span><br><span class="line">rm *.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>朴素dijkstra算法</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路问题"><a href="#最短路问题" class="headerlink" title="最短路问题"></a>最短路问题</h1><p><img src="https://cdn.acwing.com/media/article/image/2022/05/02/75349_17e3c4aac9-87eb6bc1eb975af8a5d5eababb97a74.png" alt="87eb6bc1eb975af8a5d5eababb97a74.png"></p><h3 id="朴素-dijkstra-算法-——-模板题-AcWing-849-Dijkstra-求最短路-I"><a href="#朴素-dijkstra-算法-——-模板题-AcWing-849-Dijkstra-求最短路-I" class="headerlink" title="朴素 dijkstra 算法 —— 模板题 AcWing 849. Dijkstra 求最短路 I"></a>朴素 dijkstra 算法 —— 模板题 <a href="https://www.acwing.com/problem/content/851/">AcWing 849. Dijkstra 求最短路 I</a></h3><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a><a href="https://www.acwing.com/activity/content/code/content/2269489/">题解</a></h3><p><strong>时间复杂是 O(n2+m)O(n2+m), n 表示点数，m 表示边数</strong> 1.用一个 dist 数组保存源点到其余各个节点的距离，dist[i] 表示源点到节点 i 的距离。初始时，dist 数组的各个元素为无穷大。<br>用一个状态数组 state 记录是否找到了源点到该节点的最短距离，state[i] 如果为真，则表示找到了源点到节点 i 的最短距离，state[i] 如果为假，则表示源点到节点 i 的最短距离还没有找到。初始时，state 各个元素为假。</p><p>2.源点到源点的距离为 0。即 dist[1] = 0。 3.遍历 dist 数组，找到一个节点，这个节点是：没有确定最短路径的节点中距离源点最近的点。假设该节点编号为 i。此时就找到了源点到该节点的最短距离，state[i] 置为 1。</p><p>4.遍历 i 所有可以到达的节点 j，如果 dist[j] 大于 dist[i] 加上 i -&gt; j 的距离，即 dist[j] &gt; dist[i] + w[i][j]（w[i][j] 为 i -&gt; j 的距离） ，则更新 dist[j] = dist[i] + w[i][j]。</p><p>5.重复 3 4 步骤，直到所有节点的状态都被置为 1。<br>此时 dist 数组中，就保存了源点到其余各个节点的最短距离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">int g[N][N];  // 存储每条边</span><br><span class="line">int dist[N];  // 存储1号点到每个点的最短距离</span><br><span class="line">bool st[N];   // 存储每个点的最短路是否已经确定</span><br><span class="line"></span><br><span class="line">// 求1号点到n号点的最短路，如果不存在则返回-1</span><br><span class="line">int dijkstra()</span><br><span class="line">&#123;</span><br><span class="line">    memset(dist, 0x3f, sizeof dist);</span><br><span class="line">    dist[1] = 0;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; n - 1; i ++ )</span><br><span class="line">    &#123;</span><br><span class="line">        int t = -1;     // 在还未确定最短路的点中，寻找距离最小的点</span><br><span class="line">        for (int j = 1; j &lt;= n; j ++ )</span><br><span class="line">            if (!st[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j]))</span><br><span class="line">                t = j;</span><br><span class="line"></span><br><span class="line">        // 用t更新其他点的距离</span><br><span class="line">        for (int j = 1; j &lt;= n; j ++ )</span><br><span class="line">            dist[j] = min(dist[j], dist[t] + g[t][j]);</span><br><span class="line"></span><br><span class="line">        st[t] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (dist[n] == 0x3f3f3f3f) return -1;</span><br><span class="line">    return dist[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>搜索学习笔记</title>
      <link href="/2022/11/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/09/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1.BFS"></a>1.BFS</h1><p><strong>·</strong>求最小问题<br><strong>·</strong>基于迭代（不会爆栈）</p><h3 id="模型一：Flood-Fill-算法"><a href="#模型一：Flood-Fill-算法" class="headerlink" title="模型一：Flood Fill 算法"></a>模型一：Flood Fill 算法</h3><p>在线性的时间找到某个点的连通块<br><a href="https://www.acwing.com/problem/content/1099/">1097. 池塘计数</a><br><a href="https://www.acwing.com/activity/content/code/content/2302485/">池塘计数题解</a></p><p><a href="https://www.acwing.com/problem/content/1100/">1098. 城堡问题</a><br><a href="https://www.acwing.com/activity/content/code/content/3339754/">城堡问题题解</a></p><p><a href="https://www.acwing.com/problem/content/1108/">1106. 山峰和山谷</a><br><a href="https://www.acwing.com/activity/content/code/content/3340854/">山峰和山谷题解</a></p><h3 id="模型二：最短路模型"><a href="#模型二：最短路模型" class="headerlink" title="模型二：最短路模型"></a>模型二：最短路模型</h3><p><a href="https://www.acwing.com/problem/content/description/1078/">1076. 迷宫问题</a><br><a href="https://www.acwing.com/activity/content/code/content/2619456/">迷宫问题题解</a></p><p><a href="https://www.acwing.com/problem/content/190/">188. 武士风度的牛</a><br><a href="https://www.acwing.com/activity/content/code/content/2619668/">武士风度的牛题解</a></p><p><a href="https://www.acwing.com/problem/content/1102/">1100. 抓住那头牛</a><br><a href="https://www.acwing.com/activity/content/code/content/2620046/">抓住那头牛题解</a></p><h3 id="模型三：多源-BFS"><a href="#模型三：多源-BFS" class="headerlink" title="模型三：多源 BFS"></a>模型三：多源 BFS</h3><p><a href="https://">173. 矩阵距离</a><br><a href="https://www.acwing.com/activity/content/code/content/2623686/">矩阵距离题解</a></p><h2 id="2022-4-29-打卡"><a href="#2022-4-29-打卡" class="headerlink" title="2022-4-29 打卡"></a>2022-4-29 打卡</h2><h3 id="模型四：最小步数模型"><a href="#模型四：最小步数模型" class="headerlink" title="模型四：最小步数模型"></a>模型四：最小步数模型</h3><p><a href="https://www.acwing.com/problem/content/1109/">1107. 魔板</a><br><a href="https://www.acwing.com/activity/content/code/content/3346107/">魔板题解</a></p><h3 id="模型五：双端队列广搜"><a href="#模型五：双端队列广搜" class="headerlink" title="模型五：双端队列广搜"></a>模型五：双端队列广搜</h3><p>将权值为 0 存入对头，权值为 1 存入队尾<br><a href="https://www.acwing.com/problem/content/177/">175. 电路维修</a><br><a href="https://www.acwing.com/activity/content/code/content/3346618/">电路维修题解</a></p><h3 id="模型六：双向广搜"><a href="#模型六：双向广搜" class="headerlink" title="模型六：双向广搜"></a>模型六：双向广搜</h3><p>作者：yxc<br>(BFS,双向 BFS) O((LN)5)O((LN)5)<br>假设每次决策数量是 KK，那么如果直接 BFS，最坏情况下的搜索空间是 K10K10，非常大，所以会 TLE 或者 MLE。</p><p>如果采用双向 BFS，则可以把搜索空间降到 2K52K5。在实际测试中只需 20ms 左右，剪枝效果很好。</p><p>BFS 的扩展方式是：分别枚举在原字符串中使用替换规则的起点，和所使用的的替换规则。</p><p>时间复杂度<br>假设字符串长度是 LL，替换规则一共有 NN 个，则：</p><p>在最坏情况下每次会从字符串的每个位置开始，使用全部的 NN 种替换规则，因此总共会有 LNLN 种扩展方式，从起点和终点最多会分别扩展 5 步，因此总搜索空间是 2(LN)52(LN)5。</p><p>在 BFS 过程中，空间中的每个状态只会被遍历一次，因此时间复杂度是 O((LN)5)O((LN)5)。</p><p><a href="https://www.acwing.com/problem/content/192/">190. 字串变换</a><br><a href="https://www.acwing.com/activity/content/code/content/3347965/">字串变换题解</a></p><h3 id="模型七：A"><a href="#模型七：A" class="headerlink" title="模型七：A*"></a>模型七：A*</h3><p><strong>麻了，没太明白，先放一下，最后回来解决</strong><br>大佬写的真好，从广搜到 Dijkstra 的算法到 A*算法<a href="https://www.redblobgames.com/pathfinding/a-star/introduction.html">A*算法简介</a><br><a href="https://www.acwing.com/problem/content/180/">178. 第 K 短路</a></p><p><a href="https://www.acwing.com/problem/content/181/">179. 八数码</a></p><h1 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2.DFS"></a>2.DFS</h1><h3 id="模型一：DFS-之连通性模型"><a href="#模型一：DFS-之连通性模型" class="headerlink" title="模型一：DFS 之连通性模型"></a>模型一：DFS 之连通性模型</h3><p><a href="https://www.acwing.com/problem/content/description/1114/">1112. 迷宫</a><br><a href="https://www.acwing.com/activity/content/code/content/3348834/">迷宫题解</a></p><p><a href="https://www.acwing.com/problem/content/1115/">1113. 红与黑</a><br>n 和 m 是真的恶心<br><a href="https://www.acwing.com/activity/content/code/content/3349118/">红与黑题解</a></p><h2 id="2022-4-30-打卡"><a href="#2022-4-30-打卡" class="headerlink" title="2022-4-30 打卡"></a>2022-4-30 打卡</h2><h3 id="模型二：DFS-之搜索顺序"><a href="#模型二：DFS-之搜索顺序" class="headerlink" title="模型二：DFS 之搜索顺序"></a>模型二：DFS 之搜索顺序</h3><p><a href="https://www.acwing.com/problem/content/1118/">1116. 马走日</a><br><a href="https://www.acwing.com/activity/content/code/content/3360481/">马走日题解</a></p><p><a href="https://www.acwing.com/problem/content/1119/">1117. 单词接龙</a><br><a href="https://www.acwing.com/activity/content/code/content/3362819/">单词接龙题解</a></p><p><a href="https://www.acwing.com/problem/content/1120/">1118. 分成互质组</a><br><a href="https://www.acwing.com/activity/content/code/content/3363143/">分成互质组题解</a></p><h2 id="2022-5-1-打卡"><a href="#2022-5-1-打卡" class="headerlink" title="2022-5-1 打卡"></a>2022-5-1 打卡</h2><h3 id="模型三：DFS-之剪枝与优化"><a href="#模型三：DFS-之剪枝与优化" class="headerlink" title="模型三：DFS 之剪枝与优化"></a>模型三：DFS 之剪枝与优化</h3><p><a href="https://www.acwing.com/problem/content/167/">165. 小猫爬山</a></p><p><a href="https://www.acwing.com/problem/content/168/">166. 数独</a></p><p><a href="https://www.acwing.com/problem/content/169/">167. 木棒</a></p><p><a href="https://www.acwing.com/problem/content/170/">168. 生日蛋糕</a></p><h3 id="模型四：迭代加深"><a href="#模型四：迭代加深" class="headerlink" title="模型四：迭代加深"></a>模型四：迭代加深</h3><p><a href="https://www.acwing.com/problem/content/172/">170. 加成序列</a></p><h3 id="模型五：双向-DFS"><a href="#模型五：双向-DFS" class="headerlink" title="模型五：双向 DFS"></a>模型五：双向 DFS</h3><p><a href="https://www.acwing.com/problem/content/173/">171. 送礼物</a></p><h3 id="模型六：IDA"><a href="#模型六：IDA" class="headerlink" title="模型六：IDA*"></a>模型六：IDA*</h3><p><a href="https://www.acwing.com/problem/content/182/">180. 排书</a></p><p><a href="https://www.acwing.com/problem/content/183/">181. 回转游戏</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
