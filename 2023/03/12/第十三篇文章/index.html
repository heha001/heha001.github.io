<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>实习 | 向南</title><meta name="author" content="呵哈"><meta name="copyright" content="呵哈"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP 协议TCP 建立连接 TCP 数据传送 TCP 断开连接 socket 套接字socket 起源于 Unix，而 Unix&#x2F;Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write&#x2F;read –&gt; 关闭 close”模式来操作。Socket 就是该模式的一个实现， socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（">
<meta property="og:type" content="article">
<meta property="og:title" content="实习">
<meta property="og:url" content="http://heha001.github.io/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/index.html">
<meta property="og:site_name" content="向南">
<meta property="og:description" content="TCP 协议TCP 建立连接 TCP 数据传送 TCP 断开连接 socket 套接字socket 起源于 Unix，而 Unix&#x2F;Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write&#x2F;read –&gt; 关闭 close”模式来操作。Socket 就是该模式的一个实现， socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&risl=&pid=ImgRaw&r=0">
<meta property="article:published_time" content="2023-03-12T12:57:26.000Z">
<meta property="article:modified_time" content="2023-03-12T13:08:10.443Z">
<meta property="article:author" content="呵哈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&risl=&pid=ImgRaw&r=0"><link rel="shortcut icon" href="https://cn.bing.com/images/search?view=detailV2&ccid=5Q1iewBN&id=4A99B121953F90F50D7D0BF4737ABF5A89EA5ED5&thid=OIP.5Q1iewBNPvHAQDnFulfDkgAAAA&mediaurl=https%3a%2f%2fts1.cn.mm.bing.net%2fth%2fid%2fR-C.e50d627b004d3ef1c04039c5ba57c392%3frik%3d1V7qiVq%252fenP0Cw%26riu%3dhttp%253a%252f%252fwww.kt5.cn%252fwp-content%252fuploads%252f2019%252f08%252fneon-genesis-evangelion_17.jpg%26ehk%3dFewnejP%252b0OtuzlE%252f6mN68UtZ%252feFCqg1tlAteDIXFyjw%253d%26risl%3d%26pid%3dImgRaw%26r%3d0%26sres%3d1%26sresct%3d1%26srh%3d800%26srw%3d800&exph=474&expw=474&q=%e5%8a%a8%e7%94%bb%e5%a4%b4%e5%83%8f&simid=608047956667862644&FORM=IRPRST&ck=52860327B3533C01E9584BBFA59E7D7A&selectedIndex=83"><link rel="canonical" href="http://heha001.github.io/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '实习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-12 21:08:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://www.fomal.cc/static/css/runtime.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.2"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.acwing.com/media/article/image/2022/11/09/75349_184fedb35f-头像.jpg" onerror="onerror=null;src='images\3.png'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">向南</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">实习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2023-03-12T12:57:26.000Z" title="发表于 2023-03-12 20:57:26">2023-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AE%9E%E4%B9%A0/">实习</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="实习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h1><h2 id="TCP-建立连接-TCP-数据传送-TCP-断开连接"><a href="#TCP-建立连接-TCP-数据传送-TCP-断开连接" class="headerlink" title="TCP 建立连接 TCP 数据传送 TCP 断开连接"></a>TCP 建立连接 TCP 数据传送 TCP 断开连接</h2><hr>
<h1 id="socket-套接字"><a href="#socket-套接字" class="headerlink" title="socket 套接字"></a>socket 套接字</h1><p>socket 起源于 Unix，而 Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用“打开 open –&gt; 读写 write/read –&gt; 关闭 close”模式来操作。Socket 就是该模式的一个实现， socket 即是一种特殊的文件，一些 socket 函数就是对其进行的操作（读/写 IO、打开、关闭）.说白了 Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让 Socket 去组织数据，以符合指定的协议。<br>注意：其实 socket 也没有层的概念，它只是一个 facade 设计模式的应用，让编程变的更简单。是一个软件抽象层。在网络编程中，我们大量用的都是通过 socket 实现的。</p>
<hr>
<p><code>socket()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int  socket(int protofamily, int type, int protocol);</span><br></pre></td></tr></table></figure>

<ul>
<li>protofamily：即协议域，又称为协议族（family）。常用的协议族有，AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称 AF_UNIX，Unix 域 socket）、AF_ROUTE 等等。协议族决定了 socket 的地址类型，在通信中必须采用对应的地址，如 AF_INET 决定了要用 ipv4 地址（32 位的）与端口号（16 位的）的组合、AF_UNIX 决定了要用一个绝对路径名作为地址。</li>
<li>type：指定 socket 类型。常用的 socket 类型有，SOCK_STREAM、SOCK_DGRAM、SOCK_RAW、SOCK_PACKET、SOCK_SEQPACKET 等等（socket 的类型有哪些？）。</li>
<li>protocol：故名思意，就是指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC 等，它们分别对应 TCP 传输协议、UDP 传输协议、STCP 传输协议、TIPC 传输协议。<br><br>
当`protocol`为`0`时，会自动选择`type`类型对应的默认协议</li>
</ul>
<hr>
<p><code>bind()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd：即 socket 描述字，它是通过 socket()函数创建了，唯一标识一个 socket。bind()函数就是将给这个描述字绑定一个名字。</li>
<li>addr：一个 const struct sockaddr *指针，指向要绑定给 sockfd 的协议地址。这个地址结构根据地址创建 socket 时的地址协议族的不同而不同。</li>
<li>addrlen：对应的是地址的长度。</li>
</ul>
<hr>
<p><code>close()</code>函数：关闭打开的文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int close(int fd);</span><br></pre></td></tr></table></figure>

<hr>
<p><code>recvfrom()</code>/<code>sendto()</code>函数：网络 I/O 操作</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int recvfrom(int s, void *buf, int len, unsigned int flags, struct sockaddr *from, int *fromlen);</span><br><span class="line">//从指定地址接收UDP数据报</span><br><span class="line"></span><br><span class="line">int sendto (int s, const void *buf, int len, unsigned int flags, const struct sockaddr *to, int tolen);</span><br><span class="line">//把UDP数据报发给指定地址</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><div style="width: 50pt">\s</td>
<td align="left">socket 描述符。</td>
</tr>
<tr>
<td align="center">\buf</td>
<td align="left">UDP 数据报缓存地址。</td>
</tr>
<tr>
<td align="center">\len</td>
<td align="left">UDP 数据报长度。</td>
</tr>
<tr>
<td align="center">\flags</td>
<td align="left">该参数一般为 0。</td>
</tr>
<tr>
<td align="center">\to</td>
<td align="left">sendto()函数参数，struct sockaddr_in 类型，指明 UDP 数据发往哪里报。</td>
</tr>
<tr>
<td align="center">\tolen</td>
<td align="left">对方地址长度，一般为：sizeof(struct sockaddr_in)。</td>
</tr>
<tr>
<td align="center">\from</td>
<td align="left">recvfrom()函数参数，struct sockaddr 类型，指明 UDP 数据从哪里收。</td>
</tr>
<tr>
<td align="center">\fromlen</td>
<td align="left">recvfrom()函数参数，struct sockaddr_in 类型，指明从哪里接收 UDP 数据报。</td>
</tr>
</tbody></table>
<hr>
<p><code>inet_pton()</code>函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int inet_pton(int af, const char *src, void *dst);</span><br><span class="line">//转换字符串到网络地址</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数 af 是地址族，转换后存在 dst 中</li>
<li>af = AF_INET:src 为指向字符型的地址，即 ASCII 的地址的首地址（ddd.ddd.ddd.ddd 格式的），函数将该地址转换为 in_addr 的结构体，并复制在*dst 中.</li>
</ul>
<hr>
<p><code>htons()</code>函数：将端口号由主机字节序转换为网络字节序的整数值<br><code>inet_addr()</code>函数：将一个 IP 字符串转化为一个网络字节序的整数值</p>
<hr>
<hr>
<h1 id="libcurl库进行http通讯"><a href="#libcurl库进行http通讯" class="headerlink" title="libcurl库进行http通讯"></a><code>libcurl</code>库进行<code>http</code>通讯</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><pre><code>   libcurl是一个跨平台的网络协议库，支持http, https, ftp, gopher, telnet, dict, file, 和ldap 协议。libcurl同样支持HTTPS证书授权，HTTP POST, HTTP PUT, FTP 上传, HTTP基本表单上传，代理，cookies,和用户认证。
   在基于LibCurl的程序里，主要采用callback function （回调函数）的形式完成传输任务，用户在启动传输前设置好各类参数和回调函数，当满足条件时libcurl将调用用户的回调函数实现特定功能。
   libcurl主要提供了两种发送http请求的方式，分别是Easy interface方式和multi interface方式，前者是采用阻塞的方式发送单条数据，后者采用组合的方式可以一次性发送多条数据.
</code></pre>
<h2 id="2-流程"><a href="#2-流程" class="headerlink" title="2. 流程"></a>2. 流程</h2><ol>
<li>在主线程中调用<code>curl_global_init(CURL_GLOBAL_ALL)</code>初始化</li>
<li>调用<code>curl_easy_init</code>获取一个句柄；</li>
<li>调用<code>curl_easy_setopt</code>函数设置此次传输的一些基本参数，如 url 地址、http 头、cookie 信息、发送超时时间等，其中，CURLOPT_URL 是必设的选项；</li>
<li>设置完成后，调用<code>curl_easy_perform</code>函数发送数据；</li>
<li>数据发送完毕后，调用<code>curl_easy_cleanup</code>清空句柄；</li>
<li>调用<code>curl_global_cleanup()</code>做清理工作。</li>
</ol>
<h2 id="3-基本函数"><a href="#3-基本函数" class="headerlink" title="3. 基本函数"></a>3. 基本函数</h2><ol>
<li><b>curl_global_init()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_global_init(long flags);//初始化libcurl</span><br><span class="line">函数只能调用一次，如果在curl_easy_init调用时还没调用，将有libcurl库自动调用</span><br><span class="line">虽然libcurl是线程安全的，但curl_global_init是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init</span><br><span class="line">参数：flags</span><br><span class="line">CURL_GLOBAL_ALL              //初始化所有的可能的调用。</span><br><span class="line">CURL_GLOBAL_SSL              //初始化支持 安全套接字层。</span><br><span class="line">CURL_GLOBAL_WIN32            //初始化win32套接字库。</span><br><span class="line">CURL_GLOBAL_NOTHING          //没有额外的初始化</span><br><span class="line">CURL_GLOBAL_DEFAULT          //同时初始化SSL和Win32</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><b>void curl_global_cleanup()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void curl_global_cleanup(void)</span><br><span class="line">结束libcurl使用时，用来对curl_globl_init做的工作清理。</span><br><span class="line">虽然libcurl是线程安全的，但curl_global_cleanup是不能保证线程安全的，所以不要在每个线程中都调用curl_global_init</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><b>char *curl_version()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">打印当前libcurl库的版本。</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><b>curl_easy_init()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数得到 easy interface型指针</span><br><span class="line">curl_easy_init用来初始化一个CURL的指针(有些像返回FILE类型的指针一样). 相应的在调用结束时要用curl_easy_cleanup函数清理.</span><br><span class="line">一般curl_easy_init意味着一个会话的开始. 它会返回一个easy_handle(CURL*对象), 一般都用在easy系列的函数中.</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><b>curl_easy_cleanup()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void curl_easy_cleanup(CURL *handle);</span><br><span class="line">//释放内存</span><br><span class="line">这个调用用来结束一个会话.与curl_easy_init配合着用.</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><b>curl_easy_setopt()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_easy_setopt(CURL *handle, CURLoption option, parameter);</span><br><span class="line">//设置传输选项</span><br><span class="line">几乎所有的curl 程序都要频繁的使用它.它告诉curl库.程序将有如何的行为. 比如要查看一个网页的html代码等.(这个函数有些像ioctl函数)</span><br><span class="line">参数:</span><br><span class="line">1. CURL类型的指针</span><br><span class="line">2. 各种CURLoption类型的选项.(都在curl.h库里有定义,man 也可以查看到)</span><br><span class="line">3. parameter 这个参数 既可以是个函数的指针,也可以是某个对象的指针,也可以是个long型的变量.它用什么这取决于第二个参数.</span><br><span class="line">CURLoption 这个参数的取值很多.具体的可以查看man手册.</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><b>curl_easy_perform()</b></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CURLcode curl_easy_perform(CURL *handle);</span><br><span class="line">//函数完成传输任务</span><br><span class="line">这个函数在初始化CURL类型的指针 以及curl_easy_setopt完成后调用. 就像字面的意思所说perform就像是个舞台.让我们设置的option 运作起来.</span><br></pre></td></tr></table></figure>

<h2 id="4-curl-easy-perform-函数说明（error-状态码）"><a href="#4-curl-easy-perform-函数说明（error-状态码）" class="headerlink" title="4. curl_easy_perform 函数说明（error 状态码）"></a>4. curl_easy_perform 函数说明（error 状态码）</h2><ol>
<li><code>CURLE_OK</code> //任务完成一切都好</li>
<li><code>CURLE_UNSUPPORTED_PROTOCOL</code> //不支持的协议，由 URL 的头部指定</li>
<li><code>CURLE_COULDNT_CONNECT</code> //不能连接到 remote 主机或者代理</li>
<li><code>CURLE_REMOTE_ACCESS_DENIED</code> //访问被拒绝</li>
<li><code>CURLE_HTTP_RETURNED_ERROR</code> //Http 返回错误</li>
<li><code>CURLE_READ_ERROR</code> //读本地文件错误<br><br>要获取详细的错误描述字符串，可以通过<code>const char *curl_easy_strerror(CURLcode errornum)</code>这个函数取得.</li>
</ol>
<h2 id="5-libcurl-使用的-HTTP-消息头"><a href="#5-libcurl-使用的-HTTP-消息头" class="headerlink" title="5. libcurl 使用的 HTTP 消息头"></a>5. libcurl 使用的 HTTP 消息头</h2><p>当使用<code>libcurl</code>发送<code>http</code>请求时，它会自动添加一些<code>http</code>头。我们可以通过<code>CURLOPT_HTTPHEADER</code>属性手动替换、添加或删除相应的<code>HTTP</code>消息头。<br>| | |<br>|:—|:—|<br>|Host|http1.1（大部分 http1.0)版本都要求客户端请求提供这个信息头。<br>|Pragma|”no-cache”。表示不要缓冲数据。<br>|Accept|”<em>/</em>“。表示允许接收任何类型的数据。<br>|Expect|以 POST 的方式向 HTTP 服务器提交请求时，libcurl 会设置该消息头为”100-continue”，它要求服务器</p>
<p>在正式处理该请求之前，返回一 个”OK”消息。如果 POST 的数据很小，libcurl 可能不会设置该消息头。<br><b>HTTP 协议提供了消息头，请求消息头用于告诉服务器如何处理请求;响应消息头则告诉浏览器如何处理接收到的数据。</b></p>
<h2 id="6-获取-http-应答头信息"><a href="#6-获取-http-应答头信息" class="headerlink" title="6. 获取 http 应答头信息"></a>6. 获取 http 应答头信息</h2><pre><code>   发出http请求后，服务器会返回应答头信息和应答数据，如果仅仅是打印应答头的所有内容，则直接可以通过curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, 打印函数)的方式来完成。

   需要获取的是应答头中特定的信息，比如应答码、cookies列表等，则需要通过下面这个函数：
   CURLcode curl_easy_getinfo(CURL *curl, CURLINFO info, ... );
   info参数就是我们需要获取的内容，下面是一些参数值:
   1.CURLINFO_RESPONSE_CODE
   获取应答码
   2.CURLINFO_HEADER_SIZE
   头大小
   3.CURLINFO_COOKIELIST
   cookies列表

   除了获取应答信息外，这个函数还能获取curl的一些内部信息，如请求时间、连接时间等等。
</code></pre>
<h1 id="程序员的自我修养"><a href="#程序员的自我修养" class="headerlink" title="程序员的自我修养"></a>程序员的自我修养</h1><ul>
<li>南桥芯片接低速设备的 ISA 总线。</li>
<li>北桥芯片接高速设备的 PCI(E)总线+南桥芯片。</li>
</ul>
<p>CPU 频率很难提升，遂多 CPU 和多核出现。多核处理器是 SMP(symmetrical Multi-Processing)的简化版。</p>
<ol>
<li>预编译：gcc -E mian.c -o main.i</li>
<li>编译:gcc -S main.i -o main.s</li>
<li>汇编:gcc -c main.s -o main.o</li>
<li>链接:gcc -o main main.o</li>
</ol>
<p>生成共享文件 <code>gcc -fPIC -shared -o xx.so xx.c</code><br><br><code>shared</code> 产生共享对象<br><code>PIC</code> 地址无关代码</p>
<ul>
<li>预处理器：会扩展源代码,插入所有用#include 命令指定的文件,并扩展所有的宏。</li>
<li>編译器：产生源文件的汇编代码。</li>
<li>汇编器：会将汇编代码转化成二进制目标代码文件/或者说目标文件。</li>
<li>链接器：将<code>目标文件</code>与实现<code>标准库函数</code>(如 printf)的代码合并,并产生最终的可执行文件。</li>
</ul>
<h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><p>链接就是将几个输入目标文件，加工并合并在一起组成一个输出文件的过程。<br><br>静态链接主要有两个步骤：空间及地址分配、符号解析与重定位</p>
<h2 id="空间和地址分配"><a href="#空间和地址分配" class="headerlink" title="空间和地址分配"></a>空间和地址分配</h2><ul>
<li>扫描所有输入目标文件，获得各段长度、属性和位置，并收集所有符号表中的符号定义和符号引用，放在一个统一的全局符号表内。</li>
<li>将输入文件中相同性质的段合并成输出文件的一个段，比如将输入文件所有的“.text”段合并成输出文件的“.text”。</li>
<li>为输出文件各段确定空间地址。空间地址有两种，一种是各段在可执行文件中的偏移地址，另一个是指进程的虚拟空间地址，链接过程主要关注虚拟空间地址。(这个过程实际上就是指定可执行文件与进程执行时的虚拟地址空间的映射关系)</li>
<li>由符号在段中的偏移值，确定各符号定义的虚拟地址。</li>
</ul>
<h2 id="符号解析与重定位"><a href="#符号解析与重定位" class="headerlink" title="符号解析与重定位"></a>符号解析与重定位</h2><ul>
<li>进行符号解析： 将各符号引用与输入文件某一个确定的符号定义联系在一起，如果找不到就报未定义错误。从普通程序员角度看，符号解析占链接的主要部分。</li>
<li>根据重定位表和符号定义的地址，确定每一个重定位入口的地址。<br>输入文件进行符号引用处，由于不知道相应符号的地址，所以需要将符号标记下来进行重定位，这个记录表就成为重定位表，或者重定位段。重定位表实质上是一个具有特定结构的数组，每一个数组元素都包含几点信息，重定位入口的偏移值、符号和重定位入口的类型。 -输入文件中每一个引用了外部符号的段都对应一个重定位段，如代码段“.text”对应的重定位段叫“.rel.text”.</li>
<li>指令地址修正。<br>由于不同 cpu 的寻址方式不同，所以每一个重定位入口处的实际地址都需要修正。指令修正由两个要素决定，该重定位入口的类型以及其虚拟地址。入口类型决定了指令修正方式，主要有绝对寻址修正和相对寻址修正两种。</li>
</ul>
<h2 id="COMMON-块"><a href="#COMMON-块" class="headerlink" title="COMMON 块"></a>COMMON 块</h2><p>当不同的文件目标需要的 COMMON 块空间大小不一致时，以最大的为准<br><br>一个弱符号定义在多个目标文件中，而类型不同<br></p>
<ul>
<li>1.两个或两个以上强符号类型不一致（多个强符号定义非法）</li>
<li>2.有一个强符号，其他都是弱符号（输出结果和强符号相同）</li>
<li>3.两个或两个以上的弱符号类型不一致（以输入文件最大的为准）</li>
</ul>
<p>连接器不支持符号类型，无法判断各个符号类型是否一致</p>
<p>ccglDd89.o: In function ‘PanaSearchCameras’<br><br>error: ld returned 1 exit status<br><br>链接时失败， pthread 库不是 Linux 系统默认的库，连接时需要使用静态库 libpthread.a<br>在编译中要加 -lpthread 参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc thread.c -o thread -lpthread</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char *argv)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;%d\n&quot;, argc);</span><br><span class="line">    for(int i = 0; i &lt; argc; i ++)</span><br><span class="line">        printf(&quot;%s\n&quot;, argv[i]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>gcc main.c -o main</li>
<li>./main 11 22 33</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">./main</span><br><span class="line">11</span><br><span class="line">22</span><br><span class="line">33</span><br></pre></td></tr></table></figure>

<p>所有分配出来的栈空间的每一个字节被初始化为<code>0xCC</code>,<code>0xCCCC</code>汉字编码为“<code>烫</code>”</p>
<h1 id="c-primer-2022-12-5"><a href="#c-primer-2022-12-5" class="headerlink" title="c++primer 2022/12/5"></a>c++primer 2022/12/5</h1><h2 id="负数取余问题"><a href="#负数取余问题" class="headerlink" title="负数取余问题"></a>负数取余问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unsigned char b = -1;</span><br><span class="line">b = 255;</span><br></pre></td></tr></table></figure>

<h3 id="如果-a-和-d-是两个自然数，d-非零，可以证明存在两个唯一的整数-q-和-r，满足-a-qd-r-且-0-≤-r-lt-d；两个数取余，余数总是为正数。"><a href="#如果-a-和-d-是两个自然数，d-非零，可以证明存在两个唯一的整数-q-和-r，满足-a-qd-r-且-0-≤-r-lt-d；两个数取余，余数总是为正数。" class="headerlink" title="如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a=qd+r 且 0 ≤ r &lt; d；两个数取余，余数总是为正数。"></a>如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a=qd+r 且 0 ≤ r &lt; d；两个数取余，余数总是为正数。</h3><blockquote>
<p>5%3=3x1+2，商为 1，余数为 2；<br>(-5)%(-3)=(-3)x2+1，商为 2，余数为 1；<br>5%(-3)=(-3)x(-1)+2，商为-1，余数为 2；<br>(-5)%3=3x(-2)+1，商为-2，余数为 1；</p>
</blockquote>
<h3 id="如果-a-与-d-是整数，d-非零，那么余数-r-满足这样的关系：a-qd-r-q-为整数，且-0-≤-r-lt-d-；"><a href="#如果-a-与-d-是整数，d-非零，那么余数-r-满足这样的关系：a-qd-r-q-为整数，且-0-≤-r-lt-d-；" class="headerlink" title="如果 a 与 d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且 0 ≤ |r| &lt; |d|；"></a>如果 a 与 d 是整数，d 非零，那么余数 r 满足这样的关系：a = qd + r , q 为整数，且 0 ≤ |r| &lt; |d|；</h3><blockquote>
<p>5%(-3) = (-3)x(-1)+2 = (-3)x(-2)-1；<br>如果正余数为 r1，负余数为 r2，那么有 r1 = r2 + d；<br>所有语言和计算器都遵循了尽量让商尽量靠近 0 的原则，即 5%(-3) 的结果为 2 而不是-1，(-5)%3 的结果是-2 而不是 1。</p>
</blockquote>
<h2 id="转义字符-输出“1”"><a href="#转义字符-输出“1”" class="headerlink" title="转义字符 输出“1”"></a>转义字符 输出“1”</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; &quot;\&quot;1\&quot;&quot; &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>(1)‘a ‘, L’a’, “a”, L”a” //字符字面值，宽字符字面值，字符串字面值，宽字符串字面值；<br><br>(2) 10, 10u, 10L, 10uL, 012, 0xC //整形字面值，无符号整形字面值，长整形字面值，无符号长整形字面值，八进制整形字面值，十六进制整形字面值；<br><br>(3) 3.14, 3.14f, 3.14L //浮点型字面值，单精度浮点型字面值，扩展精度浮点型字面值；<br><br>(4) 10, 10u, 10., 10e-2 //整形字面值，无符号整形字面值，浮点型字面值，浮点型字面值。<br></p>
<h2 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h2><p>一个特性，它的第 n+1 行第 m+1 列的元素值为 C(n,m);<br>n!/(n - m)!m!</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">       int i = 100;</span><br><span class="line">       for (int i = 0; i &lt; 1; i++)</span><br><span class="line">	       cout &lt;&lt; i &lt;&lt; endl;	//0</span><br><span class="line">       cout &lt;&lt; i &lt;&lt; endl;		//100</span><br><span class="line">       return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第三章-字符串、向量、数组"><a href="#第三章-字符串、向量、数组" class="headerlink" title="第三章 字符串、向量、数组"></a>第三章 字符串、向量、数组</h2><h3 id="命名空间-using-声明"><a href="#命名空间-using-声明" class="headerlink" title="命名空间 using 声明"></a>命名空间 <code>using</code> 声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br></pre></td></tr></table></figure>

<h3 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型<code>string</code></h3><blockquote>
<p>可变长的字符序列<br>string 对象的下标运算符可用于访问已存在的元素，不可以用于添加元素</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">string s1;</span><br><span class="line">string s2(s1);</span><br><span class="line">string s2 = s1;            等同于s2(s1)</span><br><span class="line">string s3(&quot;value&quot;);</span><br><span class="line">string s3 = &quot;value&quot;;       等同于s3(&quot;value&quot;)</span><br><span class="line">string s4(n, &#x27;c&#x27;);         把s4初始为连续n个c组成的串</span><br></pre></td></tr></table></figure>

<blockquote>
<p>string 操作</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">os &lt;&lt; s           //将s写到输出流os中，返回os</span><br><span class="line">is &gt;&gt; s           //从is中读取字符串赋给s，字符串以空白分隔，返回is</span><br><span class="line">getline(is, s)    //从is中读取一行赋给s，返回is</span><br><span class="line">s.empty()         //s为空返回true，否则返回false ，返回bool类型</span><br><span class="line">s.size()          //返回s中字符的个数</span><br><span class="line">s[n]              //返回s中第n个字符的引用，位置n从0计起</span><br><span class="line">s1 + s2           //返回s1和s2连接后的结果</span><br><span class="line">s1 = s2           //用s2中的副本替代s1中原来的字符</span><br><span class="line">s1 == s2          //判s1和s2等不等</span><br><span class="line">s1 = s2           //对大小写敏感</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=      //利用字符在字典中的顺序进行比较</span><br></pre></td></tr></table></figure>

<blockquote>
<p>cctype 头文件中的函数</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">isalnum(c)    //c全为数字或数字式时为真</span><br><span class="line">isalpha(c)    //c全为字母时为真</span><br><span class="line">iscntrl(c)    //c是控制字符时为真</span><br><span class="line">isdigit(c)    //当c是数字时为真</span><br><span class="line">isgragh(c)    //当c不是空格但可打印时为真</span><br><span class="line">islower(c)    //当c不是小写字母时为真</span><br><span class="line">isprint(c)    //当c是可打印字符时为真</span><br><span class="line">ispunct(c)    //当c是标点符号时为真</span><br><span class="line">isspace(c)    //当c是空白时为真</span><br><span class="line">isupper(c)    //当c为大写字母时为真</span><br><span class="line">isxdigit(c)   //当c是十六进制数字时为真</span><br><span class="line">tolower(c)    //c输出对应的小写字母</span><br><span class="line">toupper(c)    //输出对应的大写字母</span><br></pre></td></tr></table></figure>

<blockquote>
<p>读取未知量的<code>string</code>对象</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string word;</span><br><span class="line">      while(cin &gt;&gt; word) cout &lt;&lt; word &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>getline</code> 读取一整行</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line)) cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>empty</code> 函数 返回一个布尔值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line))</span><br><span class="line">           if(！line.empty())  //判断是否为空行</span><br><span class="line">                 cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>size</code> 函数 返回<code>string</code>长度</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">      string line;</span><br><span class="line">      while(getline(cin, line))</span><br><span class="line">           if(line.size() &gt; 10)  //判断长度是否大于10</span><br><span class="line">                 cout &lt;&lt; line &lt;&lt; endl;</span><br><span class="line">      return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>string</code>类<code>size</code>函数返回值为<code>size_type</code>类型<br><code>string</code>比较时采用字典序<br><code>string</code>相加时不能字面值直接相加</p>
</blockquote>
<h1 id="c-primer-2022-12-6"><a href="#c-primer-2022-12-6" class="headerlink" title="c++primer 2022/12/6"></a>c++primer 2022/12/6</h1><h3 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型<code>vector</code></h3><blockquote>
<p>标准库类型 vector 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。vector 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 vector。（如果不确定元素的确切个数，使用 vector 而不使用数组）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//头文件</span><br><span class="line">#include &lt;vector&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//初始化</span><br><span class="line">vector&lt;int&gt; v1(10, 1)      //10个元素,初值为1;</span><br><span class="line">vector&lt;int&gt; v2&#123;10, 1&#125;      //2个元素,分别为10, 1;</span><br><span class="line">vector&lt;string&gt; v3&#123;10&#125;      //10个元素,花括号内的值类型和元素类型相同为列表初始化;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//vector操作</span><br><span class="line">v.empty()           判空</span><br><span class="line">v.size()            返回v的个数</span><br><span class="line">v.push_back(t)      向v末尾添加t</span><br><span class="line">v[n]                返回v的第n个引用</span><br><span class="line">v1 = v2             用v2的元素拷贝替换v1</span><br><span class="line">v1 = &#123;a, b, c&#125;      用列表元素拷贝替换v1</span><br><span class="line">v1 == v2            当且仅当元素个数及相应元素值相同时相等</span><br><span class="line">v1 != v2</span><br><span class="line">&lt;, &lt;=, &gt;, &gt;=       以字典序比较</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>vector</code>对象的下标运算符可用于访问已存在的元素，不可以用于添加元素</p>
</blockquote>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><blockquote>
<p>所有标准库容器都可以使用迭代器</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//运算符</span><br><span class="line">*iter               //返回迭代器所指元素的引用</span><br><span class="line">iter-&gt;mem           //解引用iter并获取该元素的名为mem的成员，等价于*iter.mem</span><br><span class="line">++iter              //令iter指示容器中的下一个元素</span><br><span class="line">--iter              //令iter指示容器中的上一个元素</span><br><span class="line">iter1 == iter2      //判等</span><br><span class="line">iter1 != iter2      //判不等</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//运算</span><br><span class="line">iter + n</span><br><span class="line">iter - n</span><br><span class="line">iter += n</span><br><span class="line">iter -= n</span><br><span class="line">iter1 - iter2    //两迭代器之间的距离，注意是没有加法运算的迭代器之间。</span><br><span class="line">&gt;, &gt;=, &lt;, &lt;=     //实质是比较两迭代器间的位置</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//类型</span><br><span class="line">vector&lt;int&gt;::iterator it1;    //知道类型的定义方式、可读写</span><br><span class="line">string::iterator it2;</span><br><span class="line"></span><br><span class="line">vector&lt;int&gt;::const_iterator it3;</span><br><span class="line">string::const_iterator it4;    //只读</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>begin</code>和<code>end</code></p>
</blockquote>
<p><code>begin</code>：返回指向的第一个元素的迭代器。<br><code>end</code>：返回容器“尾元素的下一个元素”的迭代器。<br>如果容器为空，则<code>begin</code>和<code>end</code>返回的是同一个迭代器，都是尾后迭代器。</p>
<p><code>begin</code>的具体返回类型由对象是否是常量决定，如果对象是常量，<code>begin</code>和<code>end</code>返回<code>const_iterator</code>；如果不是常量，返回<code>iterator</code>。（选用<code>auto</code>自行决定返回类型比较保险）</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<p>数组的大小固定（使用下标访问时必须严格检查是否在合理范围内）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//字符数组的特殊性：可以使用字符串字面值进行初始化，但是结尾处有一处空字符。</span><br><span class="line">char a1[] = &#123;&#x27;C&#x27;, &#x27;+&#x27;, &#x27;+&#x27;&#125;;    //无空字符</span><br><span class="line">char a2[] = &quot;C++&quot;               //结尾默认生成空字符&#x27;\0&#x27;,(为了容纳空字符，故如果规定大小的话，大小必须为4以上)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//不允许拷贝和赋值</span><br><span class="line">int a[] = &#123;o,1,2&#125;;      //正确</span><br><span class="line">int b[] = a;            //错误</span><br><span class="line">a2 = a;                 //错误</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//数组的指针与引用</span><br><span class="line">int *ptrs[10];                  //ptrs是含有10个整型指针的数组</span><br><span class="line">int &amp;refs[10] = ...;            //错误：不存在引用的数组</span><br><span class="line">int (*Parray)[10] = &amp;arr;       //Parray指向一个含有十个整数的数组</span><br><span class="line">int (&amp;arrRef)[10] = arr;        //arrRef引用一个含有10个整数的数组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>相比于<code>vector</code>来说，数组的缺点</p>
</blockquote>
<ul>
<li>不能向数组增加元素，数组大小固定，不灵活。</li>
<li>vector 可以更好地支持标准库 std。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//指针+数组</span><br><span class="line">string nums[] = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;;</span><br><span class="line">string *p = &amp;nums[0];                   //p指向nums的第一个元素</span><br><span class="line">string *p2 = nums;                      //等价如上</span><br><span class="line"></span><br><span class="line">int ia = &#123;0,1,2,3,4&#125;;</span><br><span class="line">auto ia2(ia);                           //ia2是一个整型指针，指向ia的第一个元素</span><br><span class="line">auto ia2(&amp;ia[0])                        //等价如上</span><br></pre></td></tr></table></figure>

<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><blockquote>
<p>位运算符作用于整型的运算对象，并把运算对象通过 二进制 的方式理解，并提供检查和设置二进制的功能。</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">功能</th>
<th align="center">用法</th>
<th align="center">运算规则</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>~</code></td>
<td align="center">位求反</td>
<td align="center"><code>~</code> expr</td>
<td align="center">~1 = 0; ~0 = 1<br> ~1 = -2; ~-1 = 0; ~0 = -1</td>
</tr>
<tr>
<td align="center"><code>&lt;&lt;</code></td>
<td align="center">左移</td>
<td align="center">expr1 <code>&lt;&lt;</code> expr2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&gt;&gt;</code></td>
<td align="center">右移</td>
<td align="center">expr1 <code>&gt;&gt;</code> expr2</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>&amp;</code></td>
<td align="center">位与</td>
<td align="center">expr <code>&amp;</code> expr</td>
<td align="center">0 &amp; 0 = 0<br>0 &amp; 1 = 0<br>1 &amp; 0 = 0<br>1 &amp; 1 = 1</td>
</tr>
<tr>
<td align="center"><code>^</code></td>
<td align="center">位异或</td>
<td align="center">expr <code>^</code> expr</td>
<td align="center">0 ^ 0 = 0<br>0 ^ 1 = 1<br>1 ^ 0 = 1<br>1 ^ 1 = 0</td>
</tr>
<tr>
<td align="center"><code>|</code></td>
<td align="center">位或</td>
<td align="center">expr <code>|</code> expr</td>
<td align="center">0 | 0 = 0<br>0 | 1 = 1<br>1 | 0 = 1<br>1 | 1 = 1</td>
</tr>
</tbody></table>
<h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h3><blockquote>
<p>返回一条表达式或一个类型名字所占的字节数。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line">sizeof(Sales_data);            //Sales_data类型的对象所占的空间大小</span><br><span class="line">sizeof data;                   //data类型的大小，结果如上</span><br><span class="line">sizeof p;                      //指针所占的空间大小</span><br><span class="line">sizeof *p;                     //指针所指的类型所占的空间大小，即sizeof(Sales_data)</span><br><span class="line">sizeof data.revenue;           //Sales_data的成员reveune对应类型的大小</span><br><span class="line">sizeof Sales_data::revenue;    //Sales_data的成员reveune对应类型的大小</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sizeof 运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li>对 char 或者类型为 char 的表达式执行 sizeof 运算符，结果得 1。</li>
<li>对引用类型执行 sizeof 运算得到被引用对象所占空间的大小。</li>
<li>对指针执行 sizeof 运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行 sizeof 运算得到指针指向的对象所占空间的大小，指针不需要有效。</li>
<li>对数组执行 sizeof 运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次 sizeof 运算并将所得结果求和。注意，sizeof 运算不会把数组转换成指针来处理。</li>
<li>对 string 对象或 vector 对象执行 sizeof 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。</li>
</ul>
</blockquote>
<h3 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h3><blockquote>
<p>优先级最低,先对左值进行计算，然后丢弃，真正的结果是右侧表达式的值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; (0, 1);         //输出1</span><br></pre></td></tr></table></figure>

<h3 id="try-语句块和异常处理"><a href="#try-语句块和异常处理" class="headerlink" title="try 语句块和异常处理"></a>try 语句块和异常处理</h3><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><blockquote>
<p><strong>重载函数（overloaded function）</strong>：同一作用域内的几个函数的函数名相同，但参数列表不同。参数列表不同指的是参数类型和数量不全相同。如果只是返回类型不同，这么定义重载函数是错误的，因为大多数重载函数是根据形参来匹配相应重载函数。</p>
</blockquote>
<blockquote>
<p><strong>main 函数不能重载</strong></p>
</blockquote>
<blockquote>
<p>对于形参是某种类型的引用或者指针时，则通过区分其指向的是常量对象还是非常量对象以实现函数重载。这里的<code>const</code>是底层<code>const</code>。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//以下4个函数的形参类型不同</span><br><span class="line">void look(const int *a);</span><br><span class="line">void look (int* a);</span><br><span class="line"></span><br><span class="line">void look(const int &amp;a);</span><br><span class="line">void look(int &amp; a);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>函数匹配（function matching）</strong>：是指一个把函数调用与一组重载函数中的某一个关联起来的过程，也叫<strong>重载确定（overload resolution）</strong>，编译器首先将调用的实参与一组重载函数中每一个函数的参数列表进行比较，再根据比较的结果选择并调用最佳函数。</p>
</blockquote>
<blockquote>
<p>调用重载函数会有三种可能的结果：</p>
<ul>
<li>编译器找到一个与实参最佳匹配（best match）的函数，并生成调用该函数的代码。</li>
<li>找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。</li>
<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生名为二义性调用的错误。</li>
</ul>
</blockquote>
<blockquote>
<p>重载与作用域</p>
<ul>
<li>在不同作用域无法重载函数名，内层作用域声明的标识符会覆盖掉外层作用域的标识符</li>
<li>C++的名字查找发生在类型检查之前</li>
</ul>
</blockquote>
<blockquote>
<p>内联函数和<code>constexpr</code>函数</p>
<ul>
<li>调用函数会导致一些时间和空间上的开销：保存调用者保存寄存器和被调用者保存寄存器，并在函数返回时恢复；将参数拷贝进栈中；栈顶指针寄存器和基址指针寄存器的存取等操作会消耗时间和空间。</li>
<li>内联函数（inline function）：在每个调用点上“内联地”展开的函数，不会产生常规函数时间和空间上的开销，与宏类似。</li>
<li>内联函数的声明：在函数声明前面加上关键字<code>inline</code>。</li>
<li>内联函数适用于优化规模较小、流程直接、频繁调用的函数。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">inline const string &amp; shorterString(const string &amp;s1, const string &amp; s2)</span><br><span class="line">&#123;</span><br><span class="line">  return s1.size() &lt;= size() ? s1 : s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>constexpr</code>函数(constexpr function)</strong>: 是指能用于常量表达式的函数。</p>
</blockquote>
<blockquote>
<p>定义 constexpr 函数的要求</p>
<ul>
<li>函数的返回类型和所有形参的类型都必须是字面值类型，并且返回类型前还要加上关键字 constexpr</li>
<li>函数体中有且只有一条 return 语句；</li>
<li>函数体中的语句除了 return 语句外，其它语句必须是在运行时不执行任何操作的，例如空语句、声明类型别名、 using 声明等语句；</li>
</ul>
</blockquote>
<blockquote>
<p><code>constexpr</code>函数被隐式地指定为内联函数 ，以方便在编译过程中展开</p>
</blockquote>
<blockquote>
<p>与其他函数不同，内联函数和<code>constexpr</code>函数可以定义多次，但是它的多个定义必须完全一致。 所以内联函数和<code>constexpr</code>函数一般都定义在头文件中。</p>
</blockquote>
<h1 id="c-primer-2022-12-7"><a href="#c-primer-2022-12-7" class="headerlink" title="c++primer 2022/12/7"></a>c++primer 2022/12/7</h1><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li><strong>类的基本思想</strong>：**数据抽象(data abstraction)<strong>和</strong>封装(encapsulation)**。</li>
<li><strong>数据抽象</strong>：是一种依赖于**接口(interface)<strong>和实现</strong>(implementation)**分离的编程(以及设计)技术。</li>
<li><strong>类的接口</strong>：包含了用户所能执行的操作。</li>
<li><strong>类的实现</strong>：包含了类的数据成员，负责接口实现的函数体以及定义类所需的各种私有函数。</li>
<li><strong>封装</strong>：实现了类的<strong>接口</strong>和<strong>实现</strong>的分离，隐藏了类的实现细节，使得用户只能使用类的接口而无法查看其实现细节。</li>
</ul>
<h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><h3 id="函数的声明、调用、定义"><a href="#函数的声明、调用、定义" class="headerlink" title="函数的声明、调用、定义"></a>函数的声明、调用、定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void simple();      //函数的声明</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;main() will call the simple() function:&quot; &lt;&lt; endl;</span><br><span class="line">	simple();       //函数调用</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void simple(void)   //函数定义</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;I&#x27;m but a simple function&quot; &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数和按值传递"><a href="#函数参数和按值传递" class="headerlink" title="函数参数和按值传递"></a>函数参数和按值传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int, int); //函数的声明</span><br><span class="line">void swap(int*, int*);</span><br><span class="line">int a = 10, b = 20;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	swap(a, b); //函数调用</span><br><span class="line">	swap(&amp;a, &amp;b);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">void swap(int a1, int b1) //函数定义</span><br><span class="line">&#123;</span><br><span class="line">	a1 ^= b1 ^= a1 ^= b1;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//10  20</span><br><span class="line">&#125;</span><br><span class="line">void swap(int* a1, int* b1) //函数定义</span><br><span class="line">&#123;</span><br><span class="line">	*a1 ^= *b1 ^= *a1 ^= *b1;</span><br><span class="line">	cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;//20 10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数和数组"><a href="#函数和数组" class="headerlink" title="函数和数组"></a>函数和数组</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int ArSize = 8;</span><br><span class="line">int sum_arr(int arr[], int);</span><br><span class="line">int cookies[ArSize] = &#123; 1, 2, 4, 8, 16, 32, 64, 128 &#125;;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int sum = sum_arr(cookies, ArSize);</span><br><span class="line">	cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; cookies[7] &lt;&lt; endl;     //129</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line">int sum_arr(int arr[], int n)</span><br><span class="line">&#123;</span><br><span class="line">	int total = 0;</span><br><span class="line">	for (int i = 0; i &lt; n; i++)</span><br><span class="line">		total += arr[i];</span><br><span class="line">	cout &lt;&lt; arr &lt;&lt; endl &lt;&lt; cookies &lt;&lt; endl;</span><br><span class="line">	arr[7] = 129;</span><br><span class="line">	return total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>const</code>常量保证值不能被改变，其实保证的是常量指向的内存地址所保存的数据不能被修改<br>‘基本数据类型‘的 值就保存在内存地址中，所以 const 定义的 ‘基础数据类型’ 不可被改变。</p>
<p>而引用数据类型指向的内存地址只是一个指针，通过指针来指向实际数据，也就是说，不可被改变的是指针，而不是数据，所以 const 定义的 ”引用数据类型的常量可以通过属性来修改值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	int n = 10, m = 100;</span><br><span class="line">	const int* p = &amp;m;</span><br><span class="line">	int* const q = &amp;m;</span><br><span class="line">	const int* const t = &amp;m;</span><br><span class="line">	p = &amp;n;</span><br><span class="line">	cout &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; *p &lt;&lt; endl;	//00000063EA4FFAE4 10</span><br><span class="line">	*q = n;</span><br><span class="line">	cout &lt;&lt; &quot;*q = &quot; &lt;&lt; *q &lt;&lt; endl;	//10</span><br><span class="line">	cout &lt;&lt; &quot;q = &quot; &lt;&lt; q &lt;&lt; endl;	//m的地址</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="用到的一些函数"><a href="#用到的一些函数" class="headerlink" title="用到的一些函数"></a>用到的一些函数</h1><h2 id="1-fopen"><a href="#1-fopen" class="headerlink" title="1.fopen()"></a>1.fopen()</h2><p><code>FILE *fopen(const char *filename, const char *mode)</code><br><br><code>filename</code> – 字符串，表示要打开的文件名称。<br><br><code>mode</code> – 字符串，表示文件的访问模式，可以是以下表格中的值</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">“Y”</td>
<td align="left">打开一个用于读取的文件。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w”</td>
<td align="left">创建一个用于写入的空文件。如果文件名称与已存在的文件相同，则会删除已有文件的内容，文件被视为一个新的空文件。</td>
</tr>
<tr>
<td align="left">“a”</td>
<td align="left">追加到一个文件。写操作向文件末尾追加数据。如果文件不存在，则创建文件。</td>
</tr>
<tr>
<td align="left">“r+”</td>
<td align="left">打开一个用于更新的文件，可读取也可写入。该文件必须存在。</td>
</tr>
<tr>
<td align="left">“w+”</td>
<td align="left">创建一个用于读写的空文件。</td>
</tr>
<tr>
<td align="left">“a+”</td>
<td align="left">打开一个用于读取和追加的文件。</td>
</tr>
</tbody></table>
<h2 id="2-sscanf-从字符串读取格式化输入"><a href="#2-sscanf-从字符串读取格式化输入" class="headerlink" title="2.sscanf() //从字符串读取格式化输入"></a>2.sscanf() //从字符串读取格式化输入</h2><p><code>int sscanf(const char *str, const char *format, ...)</code><br><br><code>str</code> – 这是 C 字符串，是函数检索数据的源。<br><br><code>format</code> – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 <code>format</code> 说明符。<br><code>format</code> 说明符形式为 <code>[=%[*][width][modifiers]type=]</code><br>|参数|描述|<br>|:—|:—|<br>|*| 这是一个可选的星号，表示数据是从流 stream 中读取的，但是可以被忽视，即它不存储在对应的参数中。|<br>|width|这指定了在当前读取操作中读取的最大字符数。|<br>|modifiers|为对应的附加参数所指向的数据指定一个不同于整型（针对 d、i 和 n）、无符号整型（针对 o、u 和 x）或浮点型（针对 e、f 和 g）的大小： h ：短整型（针对 d、i 和 n），或无符号短整型（针对 o、u 和 x） l ：长整型（针对 d、i 和 n），或无符号长整型（针对 o、u 和 x），或双精度型（针对 e、f 和 g） L ：长双精度型（针对 e、f 和 g）|<br>|type|一个字符，指定了要被读取的数据类型以及数据读取方式。具体参见下一个表格。|</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">合格的输入</th>
<th align="left">参数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c</td>
<td align="left">单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">十进制整数：数字前面的 + 或 - 号是可选的。</td>
<td align="left">int *</td>
</tr>
<tr>
<td align="left">e,E,f,g,G</td>
<td align="left">浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4</td>
<td align="left">float *</td>
</tr>
<tr>
<td align="left">o</td>
<td align="left">八进制整数。</td>
<td align="left">int *</td>
</tr>
<tr>
<td align="left">s</td>
<td align="left">字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。</td>
<td align="left">char *</td>
</tr>
<tr>
<td align="left">u</td>
<td align="left">无符号的十进制整数。</td>
<td align="left">unsigned int *</td>
</tr>
<tr>
<td align="left">x,X</td>
<td align="left">十六进制整数。</td>
<td align="left">int *</td>
</tr>
</tbody></table>
<p><strong>附加参数</strong> – 这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。<br><br>成功返回的是成功转换的值的个数</p>
<h2 id="3-fprintf-发送格式化输出到流-stream-中。"><a href="#3-fprintf-发送格式化输出到流-stream-中。" class="headerlink" title="3.fprintf() //发送格式化输出到流 stream 中。"></a>3.fprintf() //发送格式化输出到流 stream 中。</h2><p><code>int fprintf(FILE *stream, const char *format, ...)</code><br><br><code>stream</code> – 这是指向 FILE 对象的指针，该 FILE 对象标识了流。<br><br><code>format</code> – 这是 C 字符串，包含了要被写入到流 stream 中的文本。它可以包含嵌入的 format 标签，format 标签可被随后的附加参数中指定的值替换，并按需求进行格式化。</p>
<h2 id="4-curl-easy-perform-curl-easy-perform-执行阻止文件传输"><a href="#4-curl-easy-perform-curl-easy-perform-执行阻止文件传输" class="headerlink" title="4.curl_easy_perform() //curl_easy_perform - 执行阻止文件传输"></a>4.curl_easy_perform() //curl_easy_perform - 执行阻止文件传输</h2><p><code>CURLcode curl_easy_perform(CURL *easy_handle)</code><br><br>在<code>curl_easy_init</code>和所有<code>curl_easy_setopt</code>调用后调用此函数，并按照选项中所述执行传输。必须使用与返回的<code>curl_easy_init</code>调用相同的输入<code>easy_handle</code>调用它。<code>libcurl</code>将尝试在后续传输中重复使用相同的连接</p>
<h2 id="5-curl-easy-strerror-返回描述错误代码的字符串"><a href="#5-curl-easy-strerror-返回描述错误代码的字符串" class="headerlink" title="5.curl_easy_strerror() //返回描述错误代码的字符串"></a>5.curl_easy_strerror() //返回描述错误代码的字符串</h2><p><code>const char *curl_easy_strerror(CURLcode errornum);</code><br><br>返回一个字符串，描述在参数 errornum 中传递的 CURLcode 错误代码。</p>
<h2 id="6-fclose-关闭流-stream。刷新所有的缓冲区。"><a href="#6-fclose-关闭流-stream。刷新所有的缓冲区。" class="headerlink" title="6.fclose() //关闭流 stream。刷新所有的缓冲区。"></a>6.fclose() //关闭流 stream。刷新所有的缓冲区。</h2><p><code>int fclose(FILE *stream)</code><br><br><code>stream</code> – 这是指向 <code>FILE</code> 对象的指针，该 <code>FILE</code> 对象指定了要被关闭的流。<br><br>如果流成功关闭，则该方法返回零。如果失败，则返回 EOF。</p>
<h2 id="7：pthread-mutex-init-初始化锁变量-mutex。"><a href="#7：pthread-mutex-init-初始化锁变量-mutex。" class="headerlink" title="7：pthread_mutex_init() //初始化锁变量 mutex。"></a>7：pthread_mutex_init() //初始化锁变量 mutex。</h2><p>pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t *attr)<br>attr 为锁属性，NULL 值为默认属性。</p>
<h2 id="8：pthread-mutex-lock-加锁"><a href="#8：pthread-mutex-lock-加锁" class="headerlink" title="8：pthread_mutex_lock() //加锁"></a>8：pthread_mutex_lock() //加锁</h2><p>pthread_mutex_lock(pthread_mutex_t *mutex)</p>
<h2 id="9：pthread-mutex-tylock-加锁，但是与-8-不一样的是当锁已经在使用的时候，返回为-EBUSY，而不是挂起等待。"><a href="#9：pthread-mutex-tylock-加锁，但是与-8-不一样的是当锁已经在使用的时候，返回为-EBUSY，而不是挂起等待。" class="headerlink" title="9：pthread_mutex_tylock() //加锁，但是与 8 不一样的是当锁已经在使用的时候，返回为 EBUSY，而不是挂起等待。"></a>9：pthread_mutex_tylock() //加锁，但是与 8 不一样的是当锁已经在使用的时候，返回为 EBUSY，而不是挂起等待。</h2><p>pthread_mutex_tylock(pthread_mutex_t *mutex)</p>
<h2 id="10：pthread-mutex-unlock-释放锁"><a href="#10：pthread-mutex-unlock-释放锁" class="headerlink" title="10：pthread_mutex_unlock() //释放锁"></a>10：pthread_mutex_unlock() //释放锁</h2><p>pthread_mutex_unlock(pthread_mutex_t *mutex)</p>
<h2 id="11：pthread-mutex-destroy-使用完后释放"><a href="#11：pthread-mutex-destroy-使用完后释放" class="headerlink" title="11：pthread_mutex_destroy() //使用完后释放"></a>11：pthread_mutex_destroy() //使用完后释放</h2><p>pthread_mutex_destroy(pthread_mutex_t *mutex)</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://heha001.github.io">呵哈</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://heha001.github.io/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/">http://heha001.github.io/2023/03/12/第十三篇文章/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://heha001.github.io" target="_blank">向南</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src="/null" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" src="/null" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/11/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/"><img class="next-cover" src="https://images4.alphacoders.com/102/thumb-1920-1022425.jpg" onerror="onerror=null;src='/images%5C3.png'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">闲聊</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://cdn.acwing.com/media/article/image/2022/11/09/75349_184fedb35f-头像.jpg" onerror="this.onerror=null;this.src='/images%5C3.png'" alt="avatar"/></div><div class="author-info__name">呵哈</div><div class="author-info__description">千里之行，始于足下</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">13</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxx"><i class="fab fa-github"></i><span>Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/heha001" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:1323115242@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到呵哈的技术杂货铺，如果喜欢记得收藏奥～</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">TCP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-TCP-%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81-TCP-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.</span> <span class="toc-text">TCP 建立连接 TCP 数据传送 TCP 断开连接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#socket-%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.</span> <span class="toc-text">socket 套接字</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#libcurl%E5%BA%93%E8%BF%9B%E8%A1%8Chttp%E9%80%9A%E8%AE%AF"><span class="toc-number">3.</span> <span class="toc-text">libcurl库进行http通讯</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="toc-number">3.1.</span> <span class="toc-text">1. 简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2. 流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%9F%BA%E6%9C%AC%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3. 基本函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-curl-easy-perform-%E5%87%BD%E6%95%B0%E8%AF%B4%E6%98%8E%EF%BC%88error-%E7%8A%B6%E6%80%81%E7%A0%81%EF%BC%89"><span class="toc-number">3.4.</span> <span class="toc-text">4. curl_easy_perform 函数说明（error 状态码）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-libcurl-%E4%BD%BF%E7%94%A8%E7%9A%84-HTTP-%E6%B6%88%E6%81%AF%E5%A4%B4"><span class="toc-number">3.5.</span> <span class="toc-text">5. libcurl 使用的 HTTP 消息头</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%8E%B7%E5%8F%96-http-%E5%BA%94%E7%AD%94%E5%A4%B4%E4%BF%A1%E6%81%AF"><span class="toc-number">3.6.</span> <span class="toc-text">6. 获取 http 应答头信息</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB"><span class="toc-number">4.</span> <span class="toc-text">程序员的自我修养</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">4.1.</span> <span class="toc-text">静态链接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%92%8C%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D"><span class="toc-number">4.2.</span> <span class="toc-text">空间和地址分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">4.3.</span> <span class="toc-text">符号解析与重定位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COMMON-%E5%9D%97"><span class="toc-number">4.4.</span> <span class="toc-text">COMMON 块</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-primer-2022-12-5"><span class="toc-number">5.</span> <span class="toc-text">c++primer 2022&#x2F;12&#x2F;5</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%9F%E6%95%B0%E5%8F%96%E4%BD%99%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">负数取余问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C-a-%E5%92%8C-d-%E6%98%AF%E4%B8%A4%E4%B8%AA%E8%87%AA%E7%84%B6%E6%95%B0%EF%BC%8Cd-%E9%9D%9E%E9%9B%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AF%81%E6%98%8E%E5%AD%98%E5%9C%A8%E4%B8%A4%E4%B8%AA%E5%94%AF%E4%B8%80%E7%9A%84%E6%95%B4%E6%95%B0-q-%E5%92%8C-r%EF%BC%8C%E6%BB%A1%E8%B6%B3-a-qd-r-%E4%B8%94-0-%E2%89%A4-r-lt-d%EF%BC%9B%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%8F%96%E4%BD%99%EF%BC%8C%E4%BD%99%E6%95%B0%E6%80%BB%E6%98%AF%E4%B8%BA%E6%AD%A3%E6%95%B0%E3%80%82"><span class="toc-number">5.1.1.</span> <span class="toc-text">如果 a 和 d 是两个自然数，d 非零，可以证明存在两个唯一的整数 q 和 r，满足 a&#x3D;qd+r 且 0 ≤ r &lt; d；两个数取余，余数总是为正数。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C-a-%E4%B8%8E-d-%E6%98%AF%E6%95%B4%E6%95%B0%EF%BC%8Cd-%E9%9D%9E%E9%9B%B6%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BD%99%E6%95%B0-r-%E6%BB%A1%E8%B6%B3%E8%BF%99%E6%A0%B7%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9Aa-qd-r-q-%E4%B8%BA%E6%95%B4%E6%95%B0%EF%BC%8C%E4%B8%94-0-%E2%89%A4-r-lt-d-%EF%BC%9B"><span class="toc-number">5.1.2.</span> <span class="toc-text">如果 a 与 d 是整数，d 非零，那么余数 r 满足这样的关系：a &#x3D; qd + r , q 为整数，且 0 ≤ |r| &lt; |d|；</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6-%E8%BE%93%E5%87%BA%E2%80%9C1%E2%80%9D"><span class="toc-number">5.2.</span> <span class="toc-text">转义字符 输出“1”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92"><span class="toc-number">5.3.</span> <span class="toc-text">杨辉三角</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">5.4.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">5.5.</span> <span class="toc-text">第三章 字符串、向量、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-using-%E5%A3%B0%E6%98%8E"><span class="toc-number">5.5.1.</span> <span class="toc-text">命名空间 using 声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bstring"><span class="toc-number">5.5.2.</span> <span class="toc-text">标准库类型string</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-primer-2022-12-6"><span class="toc-number">6.</span> <span class="toc-text">c++primer 2022&#x2F;12&#x2F;6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%BA%93%E7%B1%BB%E5%9E%8Bvector"><span class="toc-number">6.0.1.</span> <span class="toc-text">标准库类型vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">6.0.2.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">6.0.3.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.4.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.5.</span> <span class="toc-text">sizeof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%97%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">6.0.6.</span> <span class="toc-text">逗号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#try-%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.0.7.</span> <span class="toc-text">try 语句块和异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">6.0.8.</span> <span class="toc-text">函数重载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#c-primer-2022-12-7"><span class="toc-number">7.</span> <span class="toc-text">c++primer 2022&#x2F;12&#x2F;7</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">7.1.</span> <span class="toc-text">类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86"><span class="toc-number">7.2.</span> <span class="toc-text">基本知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%A3%B0%E6%98%8E%E3%80%81%E8%B0%83%E7%94%A8%E3%80%81%E5%AE%9A%E4%B9%89"><span class="toc-number">7.2.1.</span> <span class="toc-text">函数的声明、调用、定义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E6%8C%89%E5%80%BC%E4%BC%A0%E9%80%92"><span class="toc-number">7.3.</span> <span class="toc-text">函数参数和按值传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">7.4.</span> <span class="toc-text">函数和数组</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E5%88%B0%E7%9A%84%E4%B8%80%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">8.</span> <span class="toc-text">用到的一些函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-fopen"><span class="toc-number">8.1.</span> <span class="toc-text">1.fopen()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-sscanf-%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%AF%BB%E5%8F%96%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5"><span class="toc-number">8.2.</span> <span class="toc-text">2.sscanf() &#x2F;&#x2F;从字符串读取格式化输入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-fprintf-%E5%8F%91%E9%80%81%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E5%88%B0%E6%B5%81-stream-%E4%B8%AD%E3%80%82"><span class="toc-number">8.3.</span> <span class="toc-text">3.fprintf() &#x2F;&#x2F;发送格式化输出到流 stream 中。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-curl-easy-perform-curl-easy-perform-%E6%89%A7%E8%A1%8C%E9%98%BB%E6%AD%A2%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93"><span class="toc-number">8.4.</span> <span class="toc-text">4.curl_easy_perform() &#x2F;&#x2F;curl_easy_perform - 执行阻止文件传输</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-curl-easy-strerror-%E8%BF%94%E5%9B%9E%E6%8F%8F%E8%BF%B0%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">8.5.</span> <span class="toc-text">5.curl_easy_strerror() &#x2F;&#x2F;返回描述错误代码的字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-fclose-%E5%85%B3%E9%97%AD%E6%B5%81-stream%E3%80%82%E5%88%B7%E6%96%B0%E6%89%80%E6%9C%89%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA%E3%80%82"><span class="toc-number">8.6.</span> <span class="toc-text">6.fclose() &#x2F;&#x2F;关闭流 stream。刷新所有的缓冲区。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%EF%BC%9Apthread-mutex-init-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%94%81%E5%8F%98%E9%87%8F-mutex%E3%80%82"><span class="toc-number">8.7.</span> <span class="toc-text">7：pthread_mutex_init() &#x2F;&#x2F;初始化锁变量 mutex。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%EF%BC%9Apthread-mutex-lock-%E5%8A%A0%E9%94%81"><span class="toc-number">8.8.</span> <span class="toc-text">8：pthread_mutex_lock() &#x2F;&#x2F;加锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%EF%BC%9Apthread-mutex-tylock-%E5%8A%A0%E9%94%81%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8E-8-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84%E6%98%AF%E5%BD%93%E9%94%81%E5%B7%B2%E7%BB%8F%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E8%BF%94%E5%9B%9E%E4%B8%BA-EBUSY%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E6%8C%82%E8%B5%B7%E7%AD%89%E5%BE%85%E3%80%82"><span class="toc-number">8.9.</span> <span class="toc-text">9：pthread_mutex_tylock() &#x2F;&#x2F;加锁，但是与 8 不一样的是当锁已经在使用的时候，返回为 EBUSY，而不是挂起等待。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EF%BC%9Apthread-mutex-unlock-%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">8.10.</span> <span class="toc-text">10：pthread_mutex_unlock() &#x2F;&#x2F;释放锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%EF%BC%9Apthread-mutex-destroy-%E4%BD%BF%E7%94%A8%E5%AE%8C%E5%90%8E%E9%87%8A%E6%94%BE"><span class="toc-number">8.11.</span> <span class="toc-text">11：pthread_mutex_destroy() &#x2F;&#x2F;使用完后释放</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/" title="实习"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/images%5C3.png'" alt="实习"/></a><div class="content"><a class="title" href="/2023/03/12/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87%E6%96%87%E7%AB%A0/" title="实习">实习</a><time datetime="2023-03-12T12:57:26.000Z" title="发表于 2023-03-12 20:57:26">2023-03-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊"><img src="https://images4.alphacoders.com/102/thumb-1920-1022425.jpg" onerror="this.onerror=null;this.src='/images%5C3.png'" alt="闲聊"/></a><div class="content"><a class="title" href="/2022/11/23/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊">闲聊</a><time datetime="2022-11-23T13:44:26.000Z" title="发表于 2022-11-23 21:44:26">2022-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/11/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/images%5C3.png'" alt="闲聊"/></a><div class="content"><a class="title" href="/2022/11/11/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊">闲聊</a><time datetime="2022-11-11T01:44:26.000Z" title="发表于 2022-11-11 09:44:26">2022-11-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/11/10/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊"><img src="https://ts1.cn.mm.bing.net/th/id/R-C.530087dc88c89712590e00a0e1d7c7fe?rik=%2b6j7mqIlERBarw&amp;riu=http%3a%2f%2fimage.lnstzy.cn%2faoaodcom%2f2019-09%2f01%2f201909011007468748.jpg.w1600.h900.jpg%3fdown&amp;ehk=nrxgNMwW6qCeuWdsSIFnbyapPh3TBQ8yJRH8PknKT%2bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" onerror="this.onerror=null;this.src='/images%5C3.png'" alt="闲聊"/></a><div class="content"><a class="title" href="/2022/11/10/%E7%AC%AC%E5%8D%81%E7%AF%87%E6%96%87%E7%AB%A0/" title="闲聊">闲聊</a><time datetime="2022-11-10T10:37:55.860Z" title="发表于 2022-11-10 18:37:55">2022-11-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 呵哈</div><div class="footer_custom_text">Hi, welcome to my <a target="_blank" rel="noopener" href="https://codersunny.com">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://love-twikoo.hehao.love/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://love-twikoo.hehao.love/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script async src="//npm.elemecdn.com/pace-js@1.2.4/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://heha001.github.io/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 算法 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://heha001.github.io/categories/前端/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🎮 前端 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://heha001.github.io/categories/Linux/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🐱‍👓 Linux (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://heha001.github.io/categories/杂物/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 杂物 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="http://heha001.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 190px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 160px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法/&quot;);" href="javascript:void(0);">算法</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://ts1.cn.mm.bing.net/th/id/R-C.a982f4ba04200c6f6d92fd3207c81b71?rik=zr3%2f6r7%2bu2lPMQ&amp;riu=http%3a%2f%2fwww.pp3.cn%2fuploads%2f1212qxn%2f222.jpg&amp;ehk=LpnEbLJb0b%2b5n0%2bJcraDvqDxKnwNCXz12zFjT2ubg5w%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端/&quot;);" href="javascript:void(0);">前端</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://images4.alphacoders.com/102/thumb-1920-1022425.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂物/&quot;);" href="javascript:void(0);">杂物</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://images4.alphacoders.com/102/thumb-1920-1022425.jpg);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Linux/&quot;);" href="javascript:void(0);">Linux</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(undefined);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/实习/&quot;);" href="javascript:void(0);">实习</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'e477e112c12e407e8771ab9798bf2c08';
  var gaud_map_key = 'e1fe6ce900976f163e368f515b8c162c';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '126.550592,45.88444';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><script data-pjax>
  function butterfly_footer_beautify_injector_config(){
    var parent_div_git = document.getElementById('footer-wrap');
    var item_html = '<div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v6.2.0" title=""><img src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&amp;logo=hexo" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" data-title="主题版本Butterfly_v4.3.1" title=""><img src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&amp;logo=bitdefender" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" data-title="本站采用多线部署，主线路托管于Vercel" title=""><img src="https://img.shields.io/badge/Hosted-Vercel-brightgreen?style=flat&amp;logo=Vercel" alt=""/></a><a class="github-badge" target="_blank" href="https://dashboard.4everland.org/" style="margin-inline:5px" data-title="本站采用多线部署，备用线路托管于4EVERLAND" title=""><img src="https://img.shields.io/badge/Hosted-4EVERLAND-22DDDD?style=flat&amp;logo=IPFS" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title=""><img src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&amp;logo=GitHub" alt=""/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title=""><img src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&amp;logo=Claris" alt=""/></a></p>';
    console.log('已挂载butterfly_footer_beautify')
    parent_div_git.insertAdjacentHTML("beforeend",item_html)
    }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_footer_beautify_injector_config();
  }
  else if (epage === cpage){
    butterfly_footer_beautify_injector_config();
  }
  </script><script async src="https://unpkg.zhimg.com/hexo-butterfly-footer-beautify@1.0.0/lib/runtime.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item swiper_container_card" style="height: auto;width: 100%"><div id="random"><div id="random-banner"><canvas id="peoplecanvas"></canvas></div><a id="random-hover" style="width:100%;height:auto;" href="javascript:toRandomPost()" rel="external nofollow noreferrer" one-link-mark="yes"><i class="fa fa-paper-plane" style="margin-left:10px"></i><div style="margin-left:10px">随便逛逛<i class="fa-solid fa-arrow-right" style="margin-left:10px"></i></div></a></div><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/10/第十篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.530087dc88c89712590e00a0e1d7c7fe?rik=%2b6j7mqIlERBarw&amp;riu=http%3a%2f%2fimage.lnstzy.cn%2faoaodcom%2f2019-09%2f01%2f201909011007468748.jpg.w1600.h900.jpg%3fdown&amp;ehk=nrxgNMwW6qCeuWdsSIFnbyapPh3TBQ8yJRH8PknKT%2bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-10</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/10/第十篇文章/&quot;);" href="javascript:void(0);" alt="">闲聊</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/10/第十篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第九篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.bc52557e09b4d4d9ed894b65e0665932?rik=tkLd7hdHlIDVvg&amp;riu=http%3a%2f%2fp16.qhimg.com%2fbdr%2f__%2fd%2f_open360%2fmovie0221%2f3.jpg&amp;ehk=1GkBQ1d5J%2bJajP8W5IMzyXOMakDQMZtuJTWcT%2fVbBcg%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第九篇文章/&quot;);" href="javascript:void(0);" alt="">闲聊</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第九篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第八篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.a982f4ba04200c6f6d92fd3207c81b71?rik=zr3%2f6r7%2bu2lPMQ&amp;riu=http%3a%2f%2fwww.pp3.cn%2fuploads%2f1212qxn%2f222.jpg&amp;ehk=LpnEbLJb0b%2b5n0%2bJcraDvqDxKnwNCXz12zFjT2ubg5w%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第八篇文章/&quot;);" href="javascript:void(0);" alt="">VUE</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第八篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第七篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.686d7705868ee5bd8df56cfc16bf5337?rik=AsnldgshfgjYJg&amp;riu=http%3a%2f%2fup.deskcity.org%2fpic%2fa0%2f22%2f64%2fa022642ddaf4206ee3b7cfa67b54559d.jpg&amp;ehk=0RWycEsEmzb%2fHT4dT%2fmysv4INn5iysUnn2%2f2r4GqjjQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第七篇文章/&quot;);" href="javascript:void(0);" alt="">js</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第七篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第六篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.686d7705868ee5bd8df56cfc16bf5337?rik=AsnldgshfgjYJg&amp;riu=http%3a%2f%2fup.deskcity.org%2fpic%2fa0%2f22%2f64%2fa022642ddaf4206ee3b7cfa67b54559d.jpg&amp;ehk=0RWycEsEmzb%2fHT4dT%2fmysv4INn5iysUnn2%2f2r4GqjjQ%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第六篇文章/&quot;);" href="javascript:void(0);" alt="">css</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第六篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第五篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.a982f4ba04200c6f6d92fd3207c81b71?rik=zr3%2f6r7%2bu2lPMQ&amp;riu=http%3a%2f%2fwww.pp3.cn%2fuploads%2f1212qxn%2f222.jpg&amp;ehk=LpnEbLJb0b%2b5n0%2bJcraDvqDxKnwNCXz12zFjT2ubg5w%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第五篇文章/&quot;);" href="javascript:void(0);" alt="">html</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第五篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第四篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images4.alphacoders.com/102/thumb-1920-1022425.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第四篇文章/&quot;);" href="javascript:void(0);" alt="">linux-tmux和vim</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第四篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第三篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.caf6b6af1876e70684227c10f58d292d?rik=GOfkmV0PKljM9w&amp;riu=http%3a%2f%2fup.8desk.com%2f6%2fpic_360%2f18%2f2e%2f5d%2f182e5db462fa9751d0d583c42097c001.png&amp;ehk=5VlGZ%2fkJ%2fHTprpGHP4a0AZ2Pt8Q2Gqz19N3%2f97ig3u0%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第三篇文章/&quot;);" href="javascript:void(0);" alt="">linux-常用文件管理命令</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第三篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第二篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://images4.alphacoders.com/102/thumb-1920-1022425.jpg" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第二篇文章/&quot;);" href="javascript:void(0);" alt="">朴素dijkstra算法</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第二篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2022/11/09/第一篇文章/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src="https://ts1.cn.mm.bing.net/th/id/R-C.530087dc88c89712590e00a0e1d7c7fe?rik=%2b6j7mqIlERBarw&amp;riu=http%3a%2f%2fimage.lnstzy.cn%2faoaodcom%2f2019-09%2f01%2f201909011007468748.jpg.w1600.h900.jpg%3fdown&amp;ehk=nrxgNMwW6qCeuWdsSIFnbyapPh3TBQ8yJRH8PknKT%2bo%3d&amp;risl=&amp;pid=ImgRaw&amp;r=0" alt="" onerror="this.src=https://cdn.cbd.int/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2022-11-09</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2022/11/09/第一篇文章/&quot;);" href="javascript:void(0);" alt="">搜索学习笔记</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2022/11/09/第一篇文章/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/js/swiper.min.js"></script><script defer data-pjax src="https://cdn.cbd.int/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/swiper_init.js"></script><script data-pjax src="https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/gsap/3.9.1/gsap.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper-anzhiyu@1.0.4/lib/people.min.js"></script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '1s');
    arr[i].setAttribute('data-wow-offset', '100');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://npm.elemecdn.com/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"left","width":300,"height":600},"mobile":{"show":true},"log":false});</script></body></html>